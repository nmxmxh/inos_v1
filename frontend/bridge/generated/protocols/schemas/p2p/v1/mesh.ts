// This file has been automatically generated by capnp-es.
import * as $ from "capnp-es";
import { Base, Base$Client, Base_Envelope, Base_Metadata, Base_Payload } from ".//base/v1/base.js";
export const _capnpFileId = BigInt("0xf434190284712409");
export class P2PMesh_FindPeersWithChunk$Params extends $.Struct {
  static readonly _capnp = {
    displayName: "findPeersWithChunk$Params",
    id: "d7e48bac787e7432",
    size: new $.ObjectSize(0, 1),
  };
  get chunkHash(): string {
    return $.utils.getText(0, this);
  }
  set chunkHash(value: string) {
    $.utils.setText(0, value, this);
  }
  toString(): string { return "P2PMesh_FindPeersWithChunk$Params_" + super.toString(); }
}
export class P2PMesh_FindPeersWithChunk$Results extends $.Struct {
  static readonly _capnp = {
    displayName: "findPeersWithChunk$Results",
    id: "e53aa451eae18ca0",
    size: new $.ObjectSize(0, 1),
  };
  static _Peers: $.ListCtor<PeerCapability>;
  _adoptPeers(value: $.Orphan<$.List<PeerCapability>>): void {
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownPeers(): $.Orphan<$.List<PeerCapability>> {
    return $.utils.disown(this.peers);
  }
  get peers(): $.List<PeerCapability> {
    return $.utils.getList(0, P2PMesh_FindPeersWithChunk$Results._Peers, this);
  }
  _hasPeers(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initPeers(length: number): $.List<PeerCapability> {
    return $.utils.initList(0, P2PMesh_FindPeersWithChunk$Results._Peers, length, this);
  }
  set peers(value: $.List<PeerCapability>) {
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  toString(): string { return "P2PMesh_FindPeersWithChunk$Results_" + super.toString(); }
}
export class P2PMesh_FindPeersWithChunk$Results$Promise {
  pipeline: $.Pipeline<any, any, P2PMesh_FindPeersWithChunk$Results>;
  constructor(pipeline: $.Pipeline<any, any, P2PMesh_FindPeersWithChunk$Results>) {
    this.pipeline = pipeline;
  }
  async promise(): Promise<P2PMesh_FindPeersWithChunk$Results> {
    return await this.pipeline.struct();
  }
}
export class P2PMesh_FindBestPeerForChunk$Params extends $.Struct {
  static readonly _capnp = {
    displayName: "findBestPeerForChunk$Params",
    id: "ea45e50df1a7c974",
    size: new $.ObjectSize(0, 1),
  };
  get chunkHash(): string {
    return $.utils.getText(0, this);
  }
  set chunkHash(value: string) {
    $.utils.setText(0, value, this);
  }
  toString(): string { return "P2PMesh_FindBestPeerForChunk$Params_" + super.toString(); }
}
export class P2PMesh_FindBestPeerForChunk$Results extends $.Struct {
  static readonly _capnp = {
    displayName: "findBestPeerForChunk$Results",
    id: "eb92330297746a07",
    size: new $.ObjectSize(0, 1),
  };
  _adoptPeer(value: $.Orphan<PeerCapability>): void {
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownPeer(): $.Orphan<PeerCapability> {
    return $.utils.disown(this.peer);
  }
  get peer(): PeerCapability {
    return $.utils.getStruct(0, PeerCapability, this);
  }
  _hasPeer(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initPeer(): PeerCapability {
    return $.utils.initStructAt(0, PeerCapability, this);
  }
  set peer(value: PeerCapability) {
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  toString(): string { return "P2PMesh_FindBestPeerForChunk$Results_" + super.toString(); }
}
export class P2PMesh_FindBestPeerForChunk$Results$Promise {
  pipeline: $.Pipeline<any, any, P2PMesh_FindBestPeerForChunk$Results>;
  constructor(pipeline: $.Pipeline<any, any, P2PMesh_FindBestPeerForChunk$Results>) {
    this.pipeline = pipeline;
  }
  async promise(): Promise<P2PMesh_FindBestPeerForChunk$Results> {
    return await this.pipeline.struct();
  }
}
export class P2PMesh_RegisterChunk$Params extends $.Struct {
  static readonly _capnp = {
    displayName: "registerChunk$Params",
    id: "9be7fbf80a6f22b9",
    size: new $.ObjectSize(16, 1),
    defaultPriority: $.getUint16Mask(1)
  };
  get chunkHash(): string {
    return $.utils.getText(0, this);
  }
  set chunkHash(value: string) {
    $.utils.setText(0, value, this);
  }
  get size(): bigint {
    return $.utils.getUint64(0, this);
  }
  set size(value: bigint) {
    $.utils.setUint64(0, value, this);
  }
  get priority(): ChunkPriority {
    return $.utils.getUint16(8, this, P2PMesh_RegisterChunk$Params._capnp.defaultPriority) as ChunkPriority;
  }
  set priority(value: ChunkPriority) {
    $.utils.setUint16(8, value, this, P2PMesh_RegisterChunk$Params._capnp.defaultPriority);
  }
  toString(): string { return "P2PMesh_RegisterChunk$Params_" + super.toString(); }
}
export class P2PMesh_RegisterChunk$Results extends $.Struct {
  static readonly _capnp = {
    displayName: "registerChunk$Results",
    id: "b9af71195c7ac6e7",
    size: new $.ObjectSize(8, 0),
  };
  get success(): boolean {
    return $.utils.getBit(0, this);
  }
  set success(value: boolean) {
    $.utils.setBit(0, value, this);
  }
  toString(): string { return "P2PMesh_RegisterChunk$Results_" + super.toString(); }
}
export class P2PMesh_RegisterChunk$Results$Promise {
  pipeline: $.Pipeline<any, any, P2PMesh_RegisterChunk$Results>;
  constructor(pipeline: $.Pipeline<any, any, P2PMesh_RegisterChunk$Results>) {
    this.pipeline = pipeline;
  }
  async promise(): Promise<P2PMesh_RegisterChunk$Results> {
    return await this.pipeline.struct();
  }
}
export class P2PMesh_UnregisterChunk$Params extends $.Struct {
  static readonly _capnp = {
    displayName: "unregisterChunk$Params",
    id: "d8866021ab796e75",
    size: new $.ObjectSize(0, 1),
  };
  get chunkHash(): string {
    return $.utils.getText(0, this);
  }
  set chunkHash(value: string) {
    $.utils.setText(0, value, this);
  }
  toString(): string { return "P2PMesh_UnregisterChunk$Params_" + super.toString(); }
}
export class P2PMesh_UnregisterChunk$Results extends $.Struct {
  static readonly _capnp = {
    displayName: "unregisterChunk$Results",
    id: "9610380e15d993df",
    size: new $.ObjectSize(8, 0),
  };
  get success(): boolean {
    return $.utils.getBit(0, this);
  }
  set success(value: boolean) {
    $.utils.setBit(0, value, this);
  }
  toString(): string { return "P2PMesh_UnregisterChunk$Results_" + super.toString(); }
}
export class P2PMesh_UnregisterChunk$Results$Promise {
  pipeline: $.Pipeline<any, any, P2PMesh_UnregisterChunk$Results>;
  constructor(pipeline: $.Pipeline<any, any, P2PMesh_UnregisterChunk$Results>) {
    this.pipeline = pipeline;
  }
  async promise(): Promise<P2PMesh_UnregisterChunk$Results> {
    return await this.pipeline.struct();
  }
}
export class P2PMesh_ScheduleChunkPrefetch$Params extends $.Struct {
  static readonly _capnp = {
    displayName: "scheduleChunkPrefetch$Params",
    id: "a539b4181d081638",
    size: new $.ObjectSize(8, 1),
    defaultPriority: $.getUint16Mask(1)
  };
  _adoptChunkHashes(value: $.Orphan<$.List<string>>): void {
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownChunkHashes(): $.Orphan<$.List<string>> {
    return $.utils.disown(this.chunkHashes);
  }
  get chunkHashes(): $.List<string> {
    return $.utils.getList(0, $.TextList, this);
  }
  _hasChunkHashes(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initChunkHashes(length: number): $.List<string> {
    return $.utils.initList(0, $.TextList, length, this);
  }
  set chunkHashes(value: $.List<string>) {
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  get priority(): PrefetchPriority {
    return $.utils.getUint16(0, this, P2PMesh_ScheduleChunkPrefetch$Params._capnp.defaultPriority) as PrefetchPriority;
  }
  set priority(value: PrefetchPriority) {
    $.utils.setUint16(0, value, this, P2PMesh_ScheduleChunkPrefetch$Params._capnp.defaultPriority);
  }
  toString(): string { return "P2PMesh_ScheduleChunkPrefetch$Params_" + super.toString(); }
}
export class P2PMesh_ScheduleChunkPrefetch$Results extends $.Struct {
  static readonly _capnp = {
    displayName: "scheduleChunkPrefetch$Results",
    id: "cb8b705d4b9e2399",
    size: new $.ObjectSize(8, 0),
  };
  get success(): boolean {
    return $.utils.getBit(0, this);
  }
  set success(value: boolean) {
    $.utils.setBit(0, value, this);
  }
  toString(): string { return "P2PMesh_ScheduleChunkPrefetch$Results_" + super.toString(); }
}
export class P2PMesh_ScheduleChunkPrefetch$Results$Promise {
  pipeline: $.Pipeline<any, any, P2PMesh_ScheduleChunkPrefetch$Results>;
  constructor(pipeline: $.Pipeline<any, any, P2PMesh_ScheduleChunkPrefetch$Results>) {
    this.pipeline = pipeline;
  }
  async promise(): Promise<P2PMesh_ScheduleChunkPrefetch$Results> {
    return await this.pipeline.struct();
  }
}
export class P2PMesh_ReportPeerPerformance$Params extends $.Struct {
  static readonly _capnp = {
    displayName: "reportPeerPerformance$Params",
    id: "e5dbf0e7f860778f",
    size: new $.ObjectSize(8, 2),
    defaultOperation: "chunk_fetch"
  };
  get peerId(): string {
    return $.utils.getText(0, this);
  }
  set peerId(value: string) {
    $.utils.setText(0, value, this);
  }
  get success(): boolean {
    return $.utils.getBit(0, this);
  }
  set success(value: boolean) {
    $.utils.setBit(0, value, this);
  }
  get latencyMs(): number {
    return $.utils.getFloat32(4, this);
  }
  set latencyMs(value: number) {
    $.utils.setFloat32(4, value, this);
  }
  get operation(): string {
    return $.utils.getText(1, this, P2PMesh_ReportPeerPerformance$Params._capnp.defaultOperation);
  }
  set operation(value: string) {
    $.utils.setText(1, value, this);
  }
  toString(): string { return "P2PMesh_ReportPeerPerformance$Params_" + super.toString(); }
}
export class P2PMesh_ReportPeerPerformance$Results extends $.Struct {
  static readonly _capnp = {
    displayName: "reportPeerPerformance$Results",
    id: "d0fc089f025736bc",
    size: new $.ObjectSize(0, 0),
  };
  toString(): string { return "P2PMesh_ReportPeerPerformance$Results_" + super.toString(); }
}
export class P2PMesh_ReportPeerPerformance$Results$Promise {
  pipeline: $.Pipeline<any, any, P2PMesh_ReportPeerPerformance$Results>;
  constructor(pipeline: $.Pipeline<any, any, P2PMesh_ReportPeerPerformance$Results>) {
    this.pipeline = pipeline;
  }
  async promise(): Promise<P2PMesh_ReportPeerPerformance$Results> {
    return await this.pipeline.struct();
  }
}
export class P2PMesh_GetPeerReputation$Params extends $.Struct {
  static readonly _capnp = {
    displayName: "getPeerReputation$Params",
    id: "a88615a6700ff7c7",
    size: new $.ObjectSize(0, 1),
  };
  get peerId(): string {
    return $.utils.getText(0, this);
  }
  set peerId(value: string) {
    $.utils.setText(0, value, this);
  }
  toString(): string { return "P2PMesh_GetPeerReputation$Params_" + super.toString(); }
}
export class P2PMesh_GetPeerReputation$Results extends $.Struct {
  static readonly _capnp = {
    displayName: "getPeerReputation$Results",
    id: "968ea51e66169aba",
    size: new $.ObjectSize(8, 0),
  };
  get score(): number {
    return $.utils.getFloat32(0, this);
  }
  set score(value: number) {
    $.utils.setFloat32(0, value, this);
  }
  get confidence(): number {
    return $.utils.getFloat32(4, this);
  }
  set confidence(value: number) {
    $.utils.setFloat32(4, value, this);
  }
  toString(): string { return "P2PMesh_GetPeerReputation$Results_" + super.toString(); }
}
export class P2PMesh_GetPeerReputation$Results$Promise {
  pipeline: $.Pipeline<any, any, P2PMesh_GetPeerReputation$Results>;
  constructor(pipeline: $.Pipeline<any, any, P2PMesh_GetPeerReputation$Results>) {
    this.pipeline = pipeline;
  }
  async promise(): Promise<P2PMesh_GetPeerReputation$Results> {
    return await this.pipeline.struct();
  }
}
export class P2PMesh_GetTopPeers$Params extends $.Struct {
  static readonly _capnp = {
    displayName: "getTopPeers$Params",
    id: "b4e288ce6413fb73",
    size: new $.ObjectSize(8, 0),
    defaultLimit: $.getUint16Mask(10)
  };
  get limit(): number {
    return $.utils.getUint16(0, this, P2PMesh_GetTopPeers$Params._capnp.defaultLimit);
  }
  set limit(value: number) {
    $.utils.setUint16(0, value, this, P2PMesh_GetTopPeers$Params._capnp.defaultLimit);
  }
  toString(): string { return "P2PMesh_GetTopPeers$Params_" + super.toString(); }
}
export class P2PMesh_GetTopPeers$Results extends $.Struct {
  static readonly _capnp = {
    displayName: "getTopPeers$Results",
    id: "c8c42f7c24931265",
    size: new $.ObjectSize(0, 1),
  };
  static _Peers: $.ListCtor<PeerCapability>;
  _adoptPeers(value: $.Orphan<$.List<PeerCapability>>): void {
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownPeers(): $.Orphan<$.List<PeerCapability>> {
    return $.utils.disown(this.peers);
  }
  get peers(): $.List<PeerCapability> {
    return $.utils.getList(0, P2PMesh_GetTopPeers$Results._Peers, this);
  }
  _hasPeers(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initPeers(length: number): $.List<PeerCapability> {
    return $.utils.initList(0, P2PMesh_GetTopPeers$Results._Peers, length, this);
  }
  set peers(value: $.List<PeerCapability>) {
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  toString(): string { return "P2PMesh_GetTopPeers$Results_" + super.toString(); }
}
export class P2PMesh_GetTopPeers$Results$Promise {
  pipeline: $.Pipeline<any, any, P2PMesh_GetTopPeers$Results>;
  constructor(pipeline: $.Pipeline<any, any, P2PMesh_GetTopPeers$Results>) {
    this.pipeline = pipeline;
  }
  async promise(): Promise<P2PMesh_GetTopPeers$Results> {
    return await this.pipeline.struct();
  }
}
export class P2PMesh_RegisterModel$Params extends $.Struct {
  static readonly _capnp = {
    displayName: "registerModel$Params",
    id: "eb9bd0707bb54521",
    size: new $.ObjectSize(0, 1),
  };
  _adoptMetadata(value: $.Orphan<ModelMetadata>): void {
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownMetadata(): $.Orphan<ModelMetadata> {
    return $.utils.disown(this.metadata);
  }
  get metadata(): ModelMetadata {
    return $.utils.getStruct(0, ModelMetadata, this);
  }
  _hasMetadata(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initMetadata(): ModelMetadata {
    return $.utils.initStructAt(0, ModelMetadata, this);
  }
  set metadata(value: ModelMetadata) {
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  toString(): string { return "P2PMesh_RegisterModel$Params_" + super.toString(); }
}
export class P2PMesh_RegisterModel$Results extends $.Struct {
  static readonly _capnp = {
    displayName: "registerModel$Results",
    id: "c5a1c70778b91926",
    size: new $.ObjectSize(8, 1),
  };
  get success(): boolean {
    return $.utils.getBit(0, this);
  }
  set success(value: boolean) {
    $.utils.setBit(0, value, this);
  }
  get modelId(): string {
    return $.utils.getText(0, this);
  }
  set modelId(value: string) {
    $.utils.setText(0, value, this);
  }
  toString(): string { return "P2PMesh_RegisterModel$Results_" + super.toString(); }
}
export class P2PMesh_RegisterModel$Results$Promise {
  pipeline: $.Pipeline<any, any, P2PMesh_RegisterModel$Results>;
  constructor(pipeline: $.Pipeline<any, any, P2PMesh_RegisterModel$Results>) {
    this.pipeline = pipeline;
  }
  async promise(): Promise<P2PMesh_RegisterModel$Results> {
    return await this.pipeline.struct();
  }
}
export class P2PMesh_FindModel$Params extends $.Struct {
  static readonly _capnp = {
    displayName: "findModel$Params",
    id: "960b42f90de4e57a",
    size: new $.ObjectSize(0, 1),
  };
  get modelId(): string {
    return $.utils.getText(0, this);
  }
  set modelId(value: string) {
    $.utils.setText(0, value, this);
  }
  toString(): string { return "P2PMesh_FindModel$Params_" + super.toString(); }
}
export class P2PMesh_FindModel$Results extends $.Struct {
  static readonly _capnp = {
    displayName: "findModel$Results",
    id: "af57907ffdfbce09",
    size: new $.ObjectSize(0, 2),
  };
  _adoptMetadata(value: $.Orphan<ModelMetadata>): void {
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownMetadata(): $.Orphan<ModelMetadata> {
    return $.utils.disown(this.metadata);
  }
  get metadata(): ModelMetadata {
    return $.utils.getStruct(0, ModelMetadata, this);
  }
  _hasMetadata(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initMetadata(): ModelMetadata {
    return $.utils.initStructAt(0, ModelMetadata, this);
  }
  set metadata(value: ModelMetadata) {
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  _adoptAvailablePeers(value: $.Orphan<$.List<string>>): void {
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownAvailablePeers(): $.Orphan<$.List<string>> {
    return $.utils.disown(this.availablePeers);
  }
  get availablePeers(): $.List<string> {
    return $.utils.getList(1, $.TextList, this);
  }
  _hasAvailablePeers(): boolean {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initAvailablePeers(length: number): $.List<string> {
    return $.utils.initList(1, $.TextList, length, this);
  }
  set availablePeers(value: $.List<string>) {
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  toString(): string { return "P2PMesh_FindModel$Results_" + super.toString(); }
}
export class P2PMesh_FindModel$Results$Promise {
  pipeline: $.Pipeline<any, any, P2PMesh_FindModel$Results>;
  constructor(pipeline: $.Pipeline<any, any, P2PMesh_FindModel$Results>) {
    this.pipeline = pipeline;
  }
  async promise(): Promise<P2PMesh_FindModel$Results> {
    return await this.pipeline.struct();
  }
}
export class P2PMesh_ListModels$Params extends $.Struct {
  static readonly _capnp = {
    displayName: "listModels$Params",
    id: "be8e8476316d8cd6",
    size: new $.ObjectSize(0, 1),
  };
  _adoptQuery(value: $.Orphan<ModelQuery>): void {
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownQuery(): $.Orphan<ModelQuery> {
    return $.utils.disown(this.query);
  }
  get query(): ModelQuery {
    return $.utils.getStruct(0, ModelQuery, this);
  }
  _hasQuery(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initQuery(): ModelQuery {
    return $.utils.initStructAt(0, ModelQuery, this);
  }
  set query(value: ModelQuery) {
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  toString(): string { return "P2PMesh_ListModels$Params_" + super.toString(); }
}
export class P2PMesh_ListModels$Results extends $.Struct {
  static readonly _capnp = {
    displayName: "listModels$Results",
    id: "c9eb963d1421b5cf",
    size: new $.ObjectSize(0, 1),
  };
  static _Models: $.ListCtor<ModelMetadata>;
  _adoptModels(value: $.Orphan<$.List<ModelMetadata>>): void {
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownModels(): $.Orphan<$.List<ModelMetadata>> {
    return $.utils.disown(this.models);
  }
  get models(): $.List<ModelMetadata> {
    return $.utils.getList(0, P2PMesh_ListModels$Results._Models, this);
  }
  _hasModels(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initModels(length: number): $.List<ModelMetadata> {
    return $.utils.initList(0, P2PMesh_ListModels$Results._Models, length, this);
  }
  set models(value: $.List<ModelMetadata>) {
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  toString(): string { return "P2PMesh_ListModels$Results_" + super.toString(); }
}
export class P2PMesh_ListModels$Results$Promise {
  pipeline: $.Pipeline<any, any, P2PMesh_ListModels$Results>;
  constructor(pipeline: $.Pipeline<any, any, P2PMesh_ListModels$Results>) {
    this.pipeline = pipeline;
  }
  async promise(): Promise<P2PMesh_ListModels$Results> {
    return await this.pipeline.struct();
  }
}
export class P2PMesh_GetMeshMetrics$Params extends $.Struct {
  static readonly _capnp = {
    displayName: "getMeshMetrics$Params",
    id: "9f23f48172580d5d",
    size: new $.ObjectSize(0, 0),
  };
  toString(): string { return "P2PMesh_GetMeshMetrics$Params_" + super.toString(); }
}
export class P2PMesh_GetMeshMetrics$Results extends $.Struct {
  static readonly _capnp = {
    displayName: "getMeshMetrics$Results",
    id: "af1dc6ec46b209a1",
    size: new $.ObjectSize(0, 1),
  };
  _adoptMetrics(value: $.Orphan<MeshMetrics>): void {
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownMetrics(): $.Orphan<MeshMetrics> {
    return $.utils.disown(this.metrics);
  }
  get metrics(): MeshMetrics {
    return $.utils.getStruct(0, MeshMetrics, this);
  }
  _hasMetrics(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initMetrics(): MeshMetrics {
    return $.utils.initStructAt(0, MeshMetrics, this);
  }
  set metrics(value: MeshMetrics) {
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  toString(): string { return "P2PMesh_GetMeshMetrics$Results_" + super.toString(); }
}
export class P2PMesh_GetMeshMetrics$Results$Promise {
  pipeline: $.Pipeline<any, any, P2PMesh_GetMeshMetrics$Results>;
  constructor(pipeline: $.Pipeline<any, any, P2PMesh_GetMeshMetrics$Results>) {
    this.pipeline = pipeline;
  }
  async promise(): Promise<P2PMesh_GetMeshMetrics$Results> {
    return await this.pipeline.struct();
  }
}
export class P2PMesh_ConnectToPeer$Params extends $.Struct {
  static readonly _capnp = {
    displayName: "connectToPeer$Params",
    id: "9ce642e79ed291a3",
    size: new $.ObjectSize(0, 2),
  };
  get peerId(): string {
    return $.utils.getText(0, this);
  }
  set peerId(value: string) {
    $.utils.setText(0, value, this);
  }
  get address(): string {
    return $.utils.getText(1, this);
  }
  set address(value: string) {
    $.utils.setText(1, value, this);
  }
  toString(): string { return "P2PMesh_ConnectToPeer$Params_" + super.toString(); }
}
export class P2PMesh_ConnectToPeer$Results extends $.Struct {
  static readonly _capnp = {
    displayName: "connectToPeer$Results",
    id: "c6cbc7d6d31337c0",
    size: new $.ObjectSize(8, 1),
  };
  get success(): boolean {
    return $.utils.getBit(0, this);
  }
  set success(value: boolean) {
    $.utils.setBit(0, value, this);
  }
  get connectionId(): string {
    return $.utils.getText(0, this);
  }
  set connectionId(value: string) {
    $.utils.setText(0, value, this);
  }
  toString(): string { return "P2PMesh_ConnectToPeer$Results_" + super.toString(); }
}
export class P2PMesh_ConnectToPeer$Results$Promise {
  pipeline: $.Pipeline<any, any, P2PMesh_ConnectToPeer$Results>;
  constructor(pipeline: $.Pipeline<any, any, P2PMesh_ConnectToPeer$Results>) {
    this.pipeline = pipeline;
  }
  async promise(): Promise<P2PMesh_ConnectToPeer$Results> {
    return await this.pipeline.struct();
  }
}
export class P2PMesh_DisconnectFromPeer$Params extends $.Struct {
  static readonly _capnp = {
    displayName: "disconnectFromPeer$Params",
    id: "96d1509d40ffca28",
    size: new $.ObjectSize(0, 1),
  };
  get peerId(): string {
    return $.utils.getText(0, this);
  }
  set peerId(value: string) {
    $.utils.setText(0, value, this);
  }
  toString(): string { return "P2PMesh_DisconnectFromPeer$Params_" + super.toString(); }
}
export class P2PMesh_DisconnectFromPeer$Results extends $.Struct {
  static readonly _capnp = {
    displayName: "disconnectFromPeer$Results",
    id: "ffed96c8183be338",
    size: new $.ObjectSize(8, 0),
  };
  get success(): boolean {
    return $.utils.getBit(0, this);
  }
  set success(value: boolean) {
    $.utils.setBit(0, value, this);
  }
  toString(): string { return "P2PMesh_DisconnectFromPeer$Results_" + super.toString(); }
}
export class P2PMesh_DisconnectFromPeer$Results$Promise {
  pipeline: $.Pipeline<any, any, P2PMesh_DisconnectFromPeer$Results>;
  constructor(pipeline: $.Pipeline<any, any, P2PMesh_DisconnectFromPeer$Results>) {
    this.pipeline = pipeline;
  }
  async promise(): Promise<P2PMesh_DisconnectFromPeer$Results> {
    return await this.pipeline.struct();
  }
}
export class P2PMesh_AllocateSharedBuffer$Params extends $.Struct {
  static readonly _capnp = {
    displayName: "allocateSharedBuffer$Params",
    id: "c534027a43e9faaa",
    size: new $.ObjectSize(8, 0),
  };
  get size(): bigint {
    return $.utils.getUint64(0, this);
  }
  set size(value: bigint) {
    $.utils.setUint64(0, value, this);
  }
  toString(): string { return "P2PMesh_AllocateSharedBuffer$Params_" + super.toString(); }
}
export class P2PMesh_AllocateSharedBuffer$Results extends $.Struct {
  static readonly _capnp = {
    displayName: "allocateSharedBuffer$Results",
    id: "cc3bad69a37cd1da",
    size: new $.ObjectSize(8, 1),
  };
  get bufferId(): string {
    return $.utils.getText(0, this);
  }
  set bufferId(value: string) {
    $.utils.setText(0, value, this);
  }
  get offset(): bigint {
    return $.utils.getUint64(0, this);
  }
  set offset(value: bigint) {
    $.utils.setUint64(0, value, this);
  }
  toString(): string { return "P2PMesh_AllocateSharedBuffer$Results_" + super.toString(); }
}
export class P2PMesh_AllocateSharedBuffer$Results$Promise {
  pipeline: $.Pipeline<any, any, P2PMesh_AllocateSharedBuffer$Results>;
  constructor(pipeline: $.Pipeline<any, any, P2PMesh_AllocateSharedBuffer$Results>) {
    this.pipeline = pipeline;
  }
  async promise(): Promise<P2PMesh_AllocateSharedBuffer$Results> {
    return await this.pipeline.struct();
  }
}
export class P2PMesh_SubscribeToEvents$Params extends $.Struct {
  static readonly _capnp = {
    displayName: "subscribeToEvents$Params",
    id: "e942bf2eb77c9b54",
    size: new $.ObjectSize(0, 2),
  };
  _adoptTopics(value: $.Orphan<$.List<string>>): void {
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownTopics(): $.Orphan<$.List<string>> {
    return $.utils.disown(this.topics);
  }
  get topics(): $.List<string> {
    return $.utils.getList(0, $.TextList, this);
  }
  _hasTopics(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initTopics(length: number): $.List<string> {
    return $.utils.initList(0, $.TextList, length, this);
  }
  set topics(value: $.List<string>) {
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  get listener(): EventListener$Client {
    return new EventListener$Client($.utils.getInterfaceClientOrNullAt(1, this));
  }
  set listener(value: EventListener$Client) {
    $.utils.setInterfacePointer(this.segment.message.addCap(value.client), $.utils.getPointer(1, this));
  }
  toString(): string { return "P2PMesh_SubscribeToEvents$Params_" + super.toString(); }
}
export class P2PMesh_SubscribeToEvents$Results extends $.Struct {
  static readonly _capnp = {
    displayName: "subscribeToEvents$Results",
    id: "994c95cbfecf9d64",
    size: new $.ObjectSize(0, 1),
  };
  get subscriptionId(): string {
    return $.utils.getText(0, this);
  }
  set subscriptionId(value: string) {
    $.utils.setText(0, value, this);
  }
  toString(): string { return "P2PMesh_SubscribeToEvents$Results_" + super.toString(); }
}
export class P2PMesh_SubscribeToEvents$Results$Promise {
  pipeline: $.Pipeline<any, any, P2PMesh_SubscribeToEvents$Results>;
  constructor(pipeline: $.Pipeline<any, any, P2PMesh_SubscribeToEvents$Results>) {
    this.pipeline = pipeline;
  }
  async promise(): Promise<P2PMesh_SubscribeToEvents$Results> {
    return await this.pipeline.struct();
  }
}
export class P2PMesh_UnsubscribeFromEvents$Params extends $.Struct {
  static readonly _capnp = {
    displayName: "unsubscribeFromEvents$Params",
    id: "a15a5a145a0fc1b5",
    size: new $.ObjectSize(0, 1),
  };
  get subscriptionId(): string {
    return $.utils.getText(0, this);
  }
  set subscriptionId(value: string) {
    $.utils.setText(0, value, this);
  }
  toString(): string { return "P2PMesh_UnsubscribeFromEvents$Params_" + super.toString(); }
}
export class P2PMesh_UnsubscribeFromEvents$Results extends $.Struct {
  static readonly _capnp = {
    displayName: "unsubscribeFromEvents$Results",
    id: "98906bc51159657e",
    size: new $.ObjectSize(8, 0),
  };
  get success(): boolean {
    return $.utils.getBit(0, this);
  }
  set success(value: boolean) {
    $.utils.setBit(0, value, this);
  }
  toString(): string { return "P2PMesh_UnsubscribeFromEvents$Results_" + super.toString(); }
}
export class P2PMesh_UnsubscribeFromEvents$Results$Promise {
  pipeline: $.Pipeline<any, any, P2PMesh_UnsubscribeFromEvents$Results>;
  constructor(pipeline: $.Pipeline<any, any, P2PMesh_UnsubscribeFromEvents$Results>) {
    this.pipeline = pipeline;
  }
  async promise(): Promise<P2PMesh_UnsubscribeFromEvents$Results> {
    return await this.pipeline.struct();
  }
}
export class P2PMesh_DelegateCompute$Params extends $.Struct {
  static readonly _capnp = {
    displayName: "delegateCompute$Params",
    id: "9cb813e1e8d6c456",
    size: new $.ObjectSize(0, 1),
  };
  _adoptEnvelope(value: $.Orphan<Base_Envelope>): void {
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownEnvelope(): $.Orphan<Base_Envelope> {
    return $.utils.disown(this.envelope);
  }
  get envelope(): Base_Envelope {
    return $.utils.getStruct(0, Base_Envelope, this);
  }
  _hasEnvelope(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initEnvelope(): Base_Envelope {
    return $.utils.initStructAt(0, Base_Envelope, this);
  }
  set envelope(value: Base_Envelope) {
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  toString(): string { return "P2PMesh_DelegateCompute$Params_" + super.toString(); }
}
export class P2PMesh_DelegateCompute$Results extends $.Struct {
  static readonly _capnp = {
    displayName: "delegateCompute$Results",
    id: "9e2c07d7b747acae",
    size: new $.ObjectSize(0, 1),
  };
  _adoptResponse(value: $.Orphan<Base_Envelope>): void {
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownResponse(): $.Orphan<Base_Envelope> {
    return $.utils.disown(this.response);
  }
  get response(): Base_Envelope {
    return $.utils.getStruct(0, Base_Envelope, this);
  }
  _hasResponse(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initResponse(): Base_Envelope {
    return $.utils.initStructAt(0, Base_Envelope, this);
  }
  set response(value: Base_Envelope) {
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  toString(): string { return "P2PMesh_DelegateCompute$Results_" + super.toString(); }
}
export class P2PMesh_DelegateCompute$Results$Promise {
  pipeline: $.Pipeline<any, any, P2PMesh_DelegateCompute$Results>;
  constructor(pipeline: $.Pipeline<any, any, P2PMesh_DelegateCompute$Results>) {
    this.pipeline = pipeline;
  }
  async promise(): Promise<P2PMesh_DelegateCompute$Results> {
    return await this.pipeline.struct();
  }
}
export class P2PMesh$Client {
  client: $.Client;
  static readonly interfaceId: bigint = BigInt("0xe07e04661d226a0b");
  constructor(client: $.Client) {
    this.client = client;
  }
  static readonly methods: [
    $.Method<P2PMesh_FindPeersWithChunk$Params, P2PMesh_FindPeersWithChunk$Results>,
    $.Method<P2PMesh_FindBestPeerForChunk$Params, P2PMesh_FindBestPeerForChunk$Results>,
    $.Method<P2PMesh_RegisterChunk$Params, P2PMesh_RegisterChunk$Results>,
    $.Method<P2PMesh_UnregisterChunk$Params, P2PMesh_UnregisterChunk$Results>,
    $.Method<P2PMesh_ScheduleChunkPrefetch$Params, P2PMesh_ScheduleChunkPrefetch$Results>,
    $.Method<P2PMesh_ReportPeerPerformance$Params, P2PMesh_ReportPeerPerformance$Results>,
    $.Method<P2PMesh_GetPeerReputation$Params, P2PMesh_GetPeerReputation$Results>,
    $.Method<P2PMesh_GetTopPeers$Params, P2PMesh_GetTopPeers$Results>,
    $.Method<P2PMesh_RegisterModel$Params, P2PMesh_RegisterModel$Results>,
    $.Method<P2PMesh_FindModel$Params, P2PMesh_FindModel$Results>,
    $.Method<P2PMesh_ListModels$Params, P2PMesh_ListModels$Results>,
    $.Method<P2PMesh_GetMeshMetrics$Params, P2PMesh_GetMeshMetrics$Results>,
    $.Method<P2PMesh_ConnectToPeer$Params, P2PMesh_ConnectToPeer$Results>,
    $.Method<P2PMesh_DisconnectFromPeer$Params, P2PMesh_DisconnectFromPeer$Results>,
    $.Method<P2PMesh_AllocateSharedBuffer$Params, P2PMesh_AllocateSharedBuffer$Results>,
    $.Method<P2PMesh_SubscribeToEvents$Params, P2PMesh_SubscribeToEvents$Results>,
    $.Method<P2PMesh_UnsubscribeFromEvents$Params, P2PMesh_UnsubscribeFromEvents$Results>,
    $.Method<P2PMesh_DelegateCompute$Params, P2PMesh_DelegateCompute$Results>
  ] = [
    {
      ParamsClass: P2PMesh_FindPeersWithChunk$Params,
      ResultsClass: P2PMesh_FindPeersWithChunk$Results,
      interfaceId: P2PMesh$Client.interfaceId,
      methodId: 0,
      interfaceName: "protocols/schemas/p2p/v1/mesh.capnp:P2PMesh",
      methodName: "findPeersWithChunk"
    },
    {
      ParamsClass: P2PMesh_FindBestPeerForChunk$Params,
      ResultsClass: P2PMesh_FindBestPeerForChunk$Results,
      interfaceId: P2PMesh$Client.interfaceId,
      methodId: 1,
      interfaceName: "protocols/schemas/p2p/v1/mesh.capnp:P2PMesh",
      methodName: "findBestPeerForChunk"
    },
    {
      ParamsClass: P2PMesh_RegisterChunk$Params,
      ResultsClass: P2PMesh_RegisterChunk$Results,
      interfaceId: P2PMesh$Client.interfaceId,
      methodId: 2,
      interfaceName: "protocols/schemas/p2p/v1/mesh.capnp:P2PMesh",
      methodName: "registerChunk"
    },
    {
      ParamsClass: P2PMesh_UnregisterChunk$Params,
      ResultsClass: P2PMesh_UnregisterChunk$Results,
      interfaceId: P2PMesh$Client.interfaceId,
      methodId: 3,
      interfaceName: "protocols/schemas/p2p/v1/mesh.capnp:P2PMesh",
      methodName: "unregisterChunk"
    },
    {
      ParamsClass: P2PMesh_ScheduleChunkPrefetch$Params,
      ResultsClass: P2PMesh_ScheduleChunkPrefetch$Results,
      interfaceId: P2PMesh$Client.interfaceId,
      methodId: 4,
      interfaceName: "protocols/schemas/p2p/v1/mesh.capnp:P2PMesh",
      methodName: "scheduleChunkPrefetch"
    },
    {
      ParamsClass: P2PMesh_ReportPeerPerformance$Params,
      ResultsClass: P2PMesh_ReportPeerPerformance$Results,
      interfaceId: P2PMesh$Client.interfaceId,
      methodId: 5,
      interfaceName: "protocols/schemas/p2p/v1/mesh.capnp:P2PMesh",
      methodName: "reportPeerPerformance"
    },
    {
      ParamsClass: P2PMesh_GetPeerReputation$Params,
      ResultsClass: P2PMesh_GetPeerReputation$Results,
      interfaceId: P2PMesh$Client.interfaceId,
      methodId: 6,
      interfaceName: "protocols/schemas/p2p/v1/mesh.capnp:P2PMesh",
      methodName: "getPeerReputation"
    },
    {
      ParamsClass: P2PMesh_GetTopPeers$Params,
      ResultsClass: P2PMesh_GetTopPeers$Results,
      interfaceId: P2PMesh$Client.interfaceId,
      methodId: 7,
      interfaceName: "protocols/schemas/p2p/v1/mesh.capnp:P2PMesh",
      methodName: "getTopPeers"
    },
    {
      ParamsClass: P2PMesh_RegisterModel$Params,
      ResultsClass: P2PMesh_RegisterModel$Results,
      interfaceId: P2PMesh$Client.interfaceId,
      methodId: 8,
      interfaceName: "protocols/schemas/p2p/v1/mesh.capnp:P2PMesh",
      methodName: "registerModel"
    },
    {
      ParamsClass: P2PMesh_FindModel$Params,
      ResultsClass: P2PMesh_FindModel$Results,
      interfaceId: P2PMesh$Client.interfaceId,
      methodId: 9,
      interfaceName: "protocols/schemas/p2p/v1/mesh.capnp:P2PMesh",
      methodName: "findModel"
    },
    {
      ParamsClass: P2PMesh_ListModels$Params,
      ResultsClass: P2PMesh_ListModels$Results,
      interfaceId: P2PMesh$Client.interfaceId,
      methodId: 10,
      interfaceName: "protocols/schemas/p2p/v1/mesh.capnp:P2PMesh",
      methodName: "listModels"
    },
    {
      ParamsClass: P2PMesh_GetMeshMetrics$Params,
      ResultsClass: P2PMesh_GetMeshMetrics$Results,
      interfaceId: P2PMesh$Client.interfaceId,
      methodId: 11,
      interfaceName: "protocols/schemas/p2p/v1/mesh.capnp:P2PMesh",
      methodName: "getMeshMetrics"
    },
    {
      ParamsClass: P2PMesh_ConnectToPeer$Params,
      ResultsClass: P2PMesh_ConnectToPeer$Results,
      interfaceId: P2PMesh$Client.interfaceId,
      methodId: 12,
      interfaceName: "protocols/schemas/p2p/v1/mesh.capnp:P2PMesh",
      methodName: "connectToPeer"
    },
    {
      ParamsClass: P2PMesh_DisconnectFromPeer$Params,
      ResultsClass: P2PMesh_DisconnectFromPeer$Results,
      interfaceId: P2PMesh$Client.interfaceId,
      methodId: 13,
      interfaceName: "protocols/schemas/p2p/v1/mesh.capnp:P2PMesh",
      methodName: "disconnectFromPeer"
    },
    {
      ParamsClass: P2PMesh_AllocateSharedBuffer$Params,
      ResultsClass: P2PMesh_AllocateSharedBuffer$Results,
      interfaceId: P2PMesh$Client.interfaceId,
      methodId: 14,
      interfaceName: "protocols/schemas/p2p/v1/mesh.capnp:P2PMesh",
      methodName: "allocateSharedBuffer"
    },
    {
      ParamsClass: P2PMesh_SubscribeToEvents$Params,
      ResultsClass: P2PMesh_SubscribeToEvents$Results,
      interfaceId: P2PMesh$Client.interfaceId,
      methodId: 15,
      interfaceName: "protocols/schemas/p2p/v1/mesh.capnp:P2PMesh",
      methodName: "subscribeToEvents"
    },
    {
      ParamsClass: P2PMesh_UnsubscribeFromEvents$Params,
      ResultsClass: P2PMesh_UnsubscribeFromEvents$Results,
      interfaceId: P2PMesh$Client.interfaceId,
      methodId: 16,
      interfaceName: "protocols/schemas/p2p/v1/mesh.capnp:P2PMesh",
      methodName: "unsubscribeFromEvents"
    },
    {
      ParamsClass: P2PMesh_DelegateCompute$Params,
      ResultsClass: P2PMesh_DelegateCompute$Results,
      interfaceId: P2PMesh$Client.interfaceId,
      methodId: 17,
      interfaceName: "protocols/schemas/p2p/v1/mesh.capnp:P2PMesh",
      methodName: "delegateCompute"
    }
  ];
  findPeersWithChunk(paramsFunc?: (params: P2PMesh_FindPeersWithChunk$Params) => void): P2PMesh_FindPeersWithChunk$Results$Promise {
    const answer = this.client.call({
      method: P2PMesh$Client.methods[0],
      paramsFunc: paramsFunc
    });
    const pipeline = new $.Pipeline(P2PMesh_FindPeersWithChunk$Results, answer);
    return new P2PMesh_FindPeersWithChunk$Results$Promise(pipeline);
  }
  findBestPeerForChunk(paramsFunc?: (params: P2PMesh_FindBestPeerForChunk$Params) => void): P2PMesh_FindBestPeerForChunk$Results$Promise {
    const answer = this.client.call({
      method: P2PMesh$Client.methods[1],
      paramsFunc: paramsFunc
    });
    const pipeline = new $.Pipeline(P2PMesh_FindBestPeerForChunk$Results, answer);
    return new P2PMesh_FindBestPeerForChunk$Results$Promise(pipeline);
  }
  registerChunk(paramsFunc?: (params: P2PMesh_RegisterChunk$Params) => void): P2PMesh_RegisterChunk$Results$Promise {
    const answer = this.client.call({
      method: P2PMesh$Client.methods[2],
      paramsFunc: paramsFunc
    });
    const pipeline = new $.Pipeline(P2PMesh_RegisterChunk$Results, answer);
    return new P2PMesh_RegisterChunk$Results$Promise(pipeline);
  }
  unregisterChunk(paramsFunc?: (params: P2PMesh_UnregisterChunk$Params) => void): P2PMesh_UnregisterChunk$Results$Promise {
    const answer = this.client.call({
      method: P2PMesh$Client.methods[3],
      paramsFunc: paramsFunc
    });
    const pipeline = new $.Pipeline(P2PMesh_UnregisterChunk$Results, answer);
    return new P2PMesh_UnregisterChunk$Results$Promise(pipeline);
  }
  scheduleChunkPrefetch(paramsFunc?: (params: P2PMesh_ScheduleChunkPrefetch$Params) => void): P2PMesh_ScheduleChunkPrefetch$Results$Promise {
    const answer = this.client.call({
      method: P2PMesh$Client.methods[4],
      paramsFunc: paramsFunc
    });
    const pipeline = new $.Pipeline(P2PMesh_ScheduleChunkPrefetch$Results, answer);
    return new P2PMesh_ScheduleChunkPrefetch$Results$Promise(pipeline);
  }
  reportPeerPerformance(paramsFunc?: (params: P2PMesh_ReportPeerPerformance$Params) => void): P2PMesh_ReportPeerPerformance$Results$Promise {
    const answer = this.client.call({
      method: P2PMesh$Client.methods[5],
      paramsFunc: paramsFunc
    });
    const pipeline = new $.Pipeline(P2PMesh_ReportPeerPerformance$Results, answer);
    return new P2PMesh_ReportPeerPerformance$Results$Promise(pipeline);
  }
  getPeerReputation(paramsFunc?: (params: P2PMesh_GetPeerReputation$Params) => void): P2PMesh_GetPeerReputation$Results$Promise {
    const answer = this.client.call({
      method: P2PMesh$Client.methods[6],
      paramsFunc: paramsFunc
    });
    const pipeline = new $.Pipeline(P2PMesh_GetPeerReputation$Results, answer);
    return new P2PMesh_GetPeerReputation$Results$Promise(pipeline);
  }
  getTopPeers(paramsFunc?: (params: P2PMesh_GetTopPeers$Params) => void): P2PMesh_GetTopPeers$Results$Promise {
    const answer = this.client.call({
      method: P2PMesh$Client.methods[7],
      paramsFunc: paramsFunc
    });
    const pipeline = new $.Pipeline(P2PMesh_GetTopPeers$Results, answer);
    return new P2PMesh_GetTopPeers$Results$Promise(pipeline);
  }
  registerModel(paramsFunc?: (params: P2PMesh_RegisterModel$Params) => void): P2PMesh_RegisterModel$Results$Promise {
    const answer = this.client.call({
      method: P2PMesh$Client.methods[8],
      paramsFunc: paramsFunc
    });
    const pipeline = new $.Pipeline(P2PMesh_RegisterModel$Results, answer);
    return new P2PMesh_RegisterModel$Results$Promise(pipeline);
  }
  findModel(paramsFunc?: (params: P2PMesh_FindModel$Params) => void): P2PMesh_FindModel$Results$Promise {
    const answer = this.client.call({
      method: P2PMesh$Client.methods[9],
      paramsFunc: paramsFunc
    });
    const pipeline = new $.Pipeline(P2PMesh_FindModel$Results, answer);
    return new P2PMesh_FindModel$Results$Promise(pipeline);
  }
  listModels(paramsFunc?: (params: P2PMesh_ListModels$Params) => void): P2PMesh_ListModels$Results$Promise {
    const answer = this.client.call({
      method: P2PMesh$Client.methods[10],
      paramsFunc: paramsFunc
    });
    const pipeline = new $.Pipeline(P2PMesh_ListModels$Results, answer);
    return new P2PMesh_ListModels$Results$Promise(pipeline);
  }
  getMeshMetrics(paramsFunc?: (params: P2PMesh_GetMeshMetrics$Params) => void): P2PMesh_GetMeshMetrics$Results$Promise {
    const answer = this.client.call({
      method: P2PMesh$Client.methods[11],
      paramsFunc: paramsFunc
    });
    const pipeline = new $.Pipeline(P2PMesh_GetMeshMetrics$Results, answer);
    return new P2PMesh_GetMeshMetrics$Results$Promise(pipeline);
  }
  connectToPeer(paramsFunc?: (params: P2PMesh_ConnectToPeer$Params) => void): P2PMesh_ConnectToPeer$Results$Promise {
    const answer = this.client.call({
      method: P2PMesh$Client.methods[12],
      paramsFunc: paramsFunc
    });
    const pipeline = new $.Pipeline(P2PMesh_ConnectToPeer$Results, answer);
    return new P2PMesh_ConnectToPeer$Results$Promise(pipeline);
  }
  disconnectFromPeer(paramsFunc?: (params: P2PMesh_DisconnectFromPeer$Params) => void): P2PMesh_DisconnectFromPeer$Results$Promise {
    const answer = this.client.call({
      method: P2PMesh$Client.methods[13],
      paramsFunc: paramsFunc
    });
    const pipeline = new $.Pipeline(P2PMesh_DisconnectFromPeer$Results, answer);
    return new P2PMesh_DisconnectFromPeer$Results$Promise(pipeline);
  }
  allocateSharedBuffer(paramsFunc?: (params: P2PMesh_AllocateSharedBuffer$Params) => void): P2PMesh_AllocateSharedBuffer$Results$Promise {
    const answer = this.client.call({
      method: P2PMesh$Client.methods[14],
      paramsFunc: paramsFunc
    });
    const pipeline = new $.Pipeline(P2PMesh_AllocateSharedBuffer$Results, answer);
    return new P2PMesh_AllocateSharedBuffer$Results$Promise(pipeline);
  }
  subscribeToEvents(paramsFunc?: (params: P2PMesh_SubscribeToEvents$Params) => void): P2PMesh_SubscribeToEvents$Results$Promise {
    const answer = this.client.call({
      method: P2PMesh$Client.methods[15],
      paramsFunc: paramsFunc
    });
    const pipeline = new $.Pipeline(P2PMesh_SubscribeToEvents$Results, answer);
    return new P2PMesh_SubscribeToEvents$Results$Promise(pipeline);
  }
  unsubscribeFromEvents(paramsFunc?: (params: P2PMesh_UnsubscribeFromEvents$Params) => void): P2PMesh_UnsubscribeFromEvents$Results$Promise {
    const answer = this.client.call({
      method: P2PMesh$Client.methods[16],
      paramsFunc: paramsFunc
    });
    const pipeline = new $.Pipeline(P2PMesh_UnsubscribeFromEvents$Results, answer);
    return new P2PMesh_UnsubscribeFromEvents$Results$Promise(pipeline);
  }
  delegateCompute(paramsFunc?: (params: P2PMesh_DelegateCompute$Params) => void): P2PMesh_DelegateCompute$Results$Promise {
    const answer = this.client.call({
      method: P2PMesh$Client.methods[17],
      paramsFunc: paramsFunc
    });
    const pipeline = new $.Pipeline(P2PMesh_DelegateCompute$Results, answer);
    return new P2PMesh_DelegateCompute$Results$Promise(pipeline);
  }
}
$.Registry.register(P2PMesh$Client.interfaceId, P2PMesh$Client);
export interface P2PMesh$Server$Target {
  findPeersWithChunk(params: P2PMesh_FindPeersWithChunk$Params, results: P2PMesh_FindPeersWithChunk$Results): Promise<void>;
  findBestPeerForChunk(params: P2PMesh_FindBestPeerForChunk$Params, results: P2PMesh_FindBestPeerForChunk$Results): Promise<void>;
  registerChunk(params: P2PMesh_RegisterChunk$Params, results: P2PMesh_RegisterChunk$Results): Promise<void>;
  unregisterChunk(params: P2PMesh_UnregisterChunk$Params, results: P2PMesh_UnregisterChunk$Results): Promise<void>;
  scheduleChunkPrefetch(params: P2PMesh_ScheduleChunkPrefetch$Params, results: P2PMesh_ScheduleChunkPrefetch$Results): Promise<void>;
  reportPeerPerformance(params: P2PMesh_ReportPeerPerformance$Params, results: P2PMesh_ReportPeerPerformance$Results): Promise<void>;
  getPeerReputation(params: P2PMesh_GetPeerReputation$Params, results: P2PMesh_GetPeerReputation$Results): Promise<void>;
  getTopPeers(params: P2PMesh_GetTopPeers$Params, results: P2PMesh_GetTopPeers$Results): Promise<void>;
  registerModel(params: P2PMesh_RegisterModel$Params, results: P2PMesh_RegisterModel$Results): Promise<void>;
  findModel(params: P2PMesh_FindModel$Params, results: P2PMesh_FindModel$Results): Promise<void>;
  listModels(params: P2PMesh_ListModels$Params, results: P2PMesh_ListModels$Results): Promise<void>;
  getMeshMetrics(params: P2PMesh_GetMeshMetrics$Params, results: P2PMesh_GetMeshMetrics$Results): Promise<void>;
  connectToPeer(params: P2PMesh_ConnectToPeer$Params, results: P2PMesh_ConnectToPeer$Results): Promise<void>;
  disconnectFromPeer(params: P2PMesh_DisconnectFromPeer$Params, results: P2PMesh_DisconnectFromPeer$Results): Promise<void>;
  allocateSharedBuffer(params: P2PMesh_AllocateSharedBuffer$Params, results: P2PMesh_AllocateSharedBuffer$Results): Promise<void>;
  subscribeToEvents(params: P2PMesh_SubscribeToEvents$Params, results: P2PMesh_SubscribeToEvents$Results): Promise<void>;
  unsubscribeFromEvents(params: P2PMesh_UnsubscribeFromEvents$Params, results: P2PMesh_UnsubscribeFromEvents$Results): Promise<void>;
  delegateCompute(params: P2PMesh_DelegateCompute$Params, results: P2PMesh_DelegateCompute$Results): Promise<void>;
}
export class P2PMesh$Server extends $.Server {
  readonly target: P2PMesh$Server$Target;
  constructor(target: P2PMesh$Server$Target) {
    super(target, [
      {
        ...P2PMesh$Client.methods[0],
        impl: target.findPeersWithChunk
      },
      {
        ...P2PMesh$Client.methods[1],
        impl: target.findBestPeerForChunk
      },
      {
        ...P2PMesh$Client.methods[2],
        impl: target.registerChunk
      },
      {
        ...P2PMesh$Client.methods[3],
        impl: target.unregisterChunk
      },
      {
        ...P2PMesh$Client.methods[4],
        impl: target.scheduleChunkPrefetch
      },
      {
        ...P2PMesh$Client.methods[5],
        impl: target.reportPeerPerformance
      },
      {
        ...P2PMesh$Client.methods[6],
        impl: target.getPeerReputation
      },
      {
        ...P2PMesh$Client.methods[7],
        impl: target.getTopPeers
      },
      {
        ...P2PMesh$Client.methods[8],
        impl: target.registerModel
      },
      {
        ...P2PMesh$Client.methods[9],
        impl: target.findModel
      },
      {
        ...P2PMesh$Client.methods[10],
        impl: target.listModels
      },
      {
        ...P2PMesh$Client.methods[11],
        impl: target.getMeshMetrics
      },
      {
        ...P2PMesh$Client.methods[12],
        impl: target.connectToPeer
      },
      {
        ...P2PMesh$Client.methods[13],
        impl: target.disconnectFromPeer
      },
      {
        ...P2PMesh$Client.methods[14],
        impl: target.allocateSharedBuffer
      },
      {
        ...P2PMesh$Client.methods[15],
        impl: target.subscribeToEvents
      },
      {
        ...P2PMesh$Client.methods[16],
        impl: target.unsubscribeFromEvents
      },
      {
        ...P2PMesh$Client.methods[17],
        impl: target.delegateCompute
      }
    ]);
    this.target = target;
  }
  client(): P2PMesh$Client {
    return new P2PMesh$Client(this);
  }
}
export class P2PMesh extends $.Interface {
  static readonly Client = P2PMesh$Client;
  static readonly Server = P2PMesh$Server;
  static readonly _capnp = {
    displayName: "P2PMesh",
    id: "e07e04661d226a0b",
    size: new $.ObjectSize(0, 0),
  };
  toString(): string { return "P2PMesh_" + super.toString(); }
}
export class EventListener_OnEvent$Params extends $.Struct {
  static readonly _capnp = {
    displayName: "onEvent$Params",
    id: "911ade9cf6cedd52",
    size: new $.ObjectSize(0, 1),
  };
  _adoptEnvelope(value: $.Orphan<Base_Envelope>): void {
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownEnvelope(): $.Orphan<Base_Envelope> {
    return $.utils.disown(this.envelope);
  }
  get envelope(): Base_Envelope {
    return $.utils.getStruct(0, Base_Envelope, this);
  }
  _hasEnvelope(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initEnvelope(): Base_Envelope {
    return $.utils.initStructAt(0, Base_Envelope, this);
  }
  set envelope(value: Base_Envelope) {
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  toString(): string { return "EventListener_OnEvent$Params_" + super.toString(); }
}
export class EventListener_OnEvent$Results extends $.Struct {
  static readonly _capnp = {
    displayName: "onEvent$Results",
    id: "e6c061b33c782605",
    size: new $.ObjectSize(0, 0),
  };
  toString(): string { return "EventListener_OnEvent$Results_" + super.toString(); }
}
export class EventListener_OnEvent$Results$Promise {
  pipeline: $.Pipeline<any, any, EventListener_OnEvent$Results>;
  constructor(pipeline: $.Pipeline<any, any, EventListener_OnEvent$Results>) {
    this.pipeline = pipeline;
  }
  async promise(): Promise<EventListener_OnEvent$Results> {
    return await this.pipeline.struct();
  }
}
export class EventListener$Client {
  client: $.Client;
  static readonly interfaceId: bigint = BigInt("0xf5b204ddf815ebc5");
  constructor(client: $.Client) {
    this.client = client;
  }
  static readonly methods: [
    $.Method<EventListener_OnEvent$Params, EventListener_OnEvent$Results>
  ] = [
    {
      ParamsClass: EventListener_OnEvent$Params,
      ResultsClass: EventListener_OnEvent$Results,
      interfaceId: EventListener$Client.interfaceId,
      methodId: 0,
      interfaceName: "protocols/schemas/p2p/v1/mesh.capnp:EventListener",
      methodName: "onEvent"
    }
  ];
  onEvent(paramsFunc?: (params: EventListener_OnEvent$Params) => void): EventListener_OnEvent$Results$Promise {
    const answer = this.client.call({
      method: EventListener$Client.methods[0],
      paramsFunc: paramsFunc
    });
    const pipeline = new $.Pipeline(EventListener_OnEvent$Results, answer);
    return new EventListener_OnEvent$Results$Promise(pipeline);
  }
}
$.Registry.register(EventListener$Client.interfaceId, EventListener$Client);
export interface EventListener$Server$Target {
  onEvent(params: EventListener_OnEvent$Params, results: EventListener_OnEvent$Results): Promise<void>;
}
export class EventListener$Server extends $.Server {
  readonly target: EventListener$Server$Target;
  constructor(target: EventListener$Server$Target) {
    super(target, [
      {
        ...EventListener$Client.methods[0],
        impl: target.onEvent
      }
    ]);
    this.target = target;
  }
  client(): EventListener$Client {
    return new EventListener$Client(this);
  }
}
/**
* Callback for receiving events wrapped in Base.Envelope
*
*/
export class EventListener extends $.Interface {
  static readonly Client = EventListener$Client;
  static readonly Server = EventListener$Server;
  static readonly _capnp = {
    displayName: "EventListener",
    id: "f5b204ddf815ebc5",
    size: new $.ObjectSize(0, 0),
  };
  toString(): string { return "EventListener_" + super.toString(); }
}
export class PeerCapability extends $.Struct {
  static readonly _capnp = {
    displayName: "PeerCapability",
    id: "c7faf55c26776162",
    size: new $.ObjectSize(24, 5),
  };
  /**
* removed unused metadata field to fix ordinal gap
*
*/
  get peerId(): string {
    return $.utils.getText(0, this);
  }
  set peerId(value: string) {
    $.utils.setText(0, value, this);
  }
  _adoptAvailableChunks(value: $.Orphan<$.List<string>>): void {
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownAvailableChunks(): $.Orphan<$.List<string>> {
    return $.utils.disown(this.availableChunks);
  }
  get availableChunks(): $.List<string> {
    return $.utils.getList(1, $.TextList, this);
  }
  _hasAvailableChunks(): boolean {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initAvailableChunks(length: number): $.List<string> {
    return $.utils.initList(1, $.TextList, length, this);
  }
  set availableChunks(value: $.List<string>) {
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  get bandwidthKbps(): number {
    return $.utils.getFloat32(0, this);
  }
  set bandwidthKbps(value: number) {
    $.utils.setFloat32(0, value, this);
  }
  get latencyMs(): number {
    return $.utils.getFloat32(4, this);
  }
  set latencyMs(value: number) {
    $.utils.setFloat32(4, value, this);
  }
  get reputation(): number {
    return $.utils.getFloat32(8, this);
  }
  set reputation(value: number) {
    $.utils.setFloat32(8, value, this);
  }
  _adoptCapabilities(value: $.Orphan<$.List<string>>): void {
    $.utils.adopt(value, $.utils.getPointer(2, this));
  }
  _disownCapabilities(): $.Orphan<$.List<string>> {
    return $.utils.disown(this.capabilities);
  }
  get capabilities(): $.List<string> {
    return $.utils.getList(2, $.TextList, this);
  }
  _hasCapabilities(): boolean {
    return !$.utils.isNull($.utils.getPointer(2, this));
  }
  _initCapabilities(length: number): $.List<string> {
    return $.utils.initList(2, $.TextList, length, this);
  }
  set capabilities(value: $.List<string>) {
    $.utils.copyFrom(value, $.utils.getPointer(2, this));
  }
  get lastSeen(): bigint {
    return $.utils.getInt64(16, this);
  }
  set lastSeen(value: bigint) {
    $.utils.setInt64(16, value, this);
  }
  get connectionState(): ConnectionState {
    return $.utils.getUint16(12, this) as ConnectionState;
  }
  set connectionState(value: ConnectionState) {
    $.utils.setUint16(12, value, this);
  }
  get region(): string {
    return $.utils.getText(3, this);
  }
  set region(value: string) {
    $.utils.setText(3, value, this);
  }
  _adoptCoordinates(value: $.Orphan<GeoCoordinates>): void {
    $.utils.adopt(value, $.utils.getPointer(4, this));
  }
  _disownCoordinates(): $.Orphan<GeoCoordinates> {
    return $.utils.disown(this.coordinates);
  }
  get coordinates(): GeoCoordinates {
    return $.utils.getStruct(4, GeoCoordinates, this);
  }
  _hasCoordinates(): boolean {
    return !$.utils.isNull($.utils.getPointer(4, this));
  }
  _initCoordinates(): GeoCoordinates {
    return $.utils.initStructAt(4, GeoCoordinates, this);
  }
  set coordinates(value: GeoCoordinates) {
    $.utils.copyFrom(value, $.utils.getPointer(4, this));
  }
  toString(): string { return "PeerCapability_" + super.toString(); }
}
export class GeoCoordinates extends $.Struct {
  static readonly _capnp = {
    displayName: "GeoCoordinates",
    id: "eaaf902aa2546456",
    size: new $.ObjectSize(8, 0),
  };
  get latitude(): number {
    return $.utils.getFloat32(0, this);
  }
  set latitude(value: number) {
    $.utils.setFloat32(0, value, this);
  }
  get longitude(): number {
    return $.utils.getFloat32(4, this);
  }
  set longitude(value: number) {
    $.utils.setFloat32(4, value, this);
  }
  toString(): string { return "GeoCoordinates_" + super.toString(); }
}
export const ConnectionState = {
  DISCONNECTED: 0,
  CONNECTING: 1,
  CONNECTED: 2,
  DEGRADED: 3,
  FAILED: 4
} as const;
export type ConnectionState = (typeof ConnectionState)[keyof typeof ConnectionState];
export class ModelMetadata extends $.Struct {
  static readonly _capnp = {
    displayName: "ModelMetadata",
    id: "9aff8a26d98da3b7",
    size: new $.ObjectSize(56, 10),
  };
  static _LayerChunks: $.ListCtor<LayerChunkMapping>;
  get modelId(): string {
    return $.utils.getText(0, this);
  }
  set modelId(value: string) {
    $.utils.setText(0, value, this);
  }
  get name(): string {
    return $.utils.getText(1, this);
  }
  set name(value: string) {
    $.utils.setText(1, value, this);
  }
  get version(): string {
    return $.utils.getText(2, this);
  }
  set version(value: string) {
    $.utils.setText(2, value, this);
  }
  get totalChunks(): number {
    return $.utils.getUint32(0, this);
  }
  set totalChunks(value: number) {
    $.utils.setUint32(0, value, this);
  }
  get totalSize(): bigint {
    return $.utils.getUint64(8, this);
  }
  set totalSize(value: bigint) {
    $.utils.setUint64(8, value, this);
  }
  _adoptChunkIds(value: $.Orphan<$.List<string>>): void {
    $.utils.adopt(value, $.utils.getPointer(3, this));
  }
  _disownChunkIds(): $.Orphan<$.List<string>> {
    return $.utils.disown(this.chunkIds);
  }
  get chunkIds(): $.List<string> {
    return $.utils.getList(3, $.TextList, this);
  }
  _hasChunkIds(): boolean {
    return !$.utils.isNull($.utils.getPointer(3, this));
  }
  _initChunkIds(length: number): $.List<string> {
    return $.utils.initList(3, $.TextList, length, this);
  }
  set chunkIds(value: $.List<string>) {
    $.utils.copyFrom(value, $.utils.getPointer(3, this));
  }
  get createdAt(): bigint {
    return $.utils.getUint64(16, this);
  }
  set createdAt(value: bigint) {
    $.utils.setUint64(16, value, this);
  }
  get lastAccessed(): bigint {
    return $.utils.getUint64(24, this);
  }
  set lastAccessed(value: bigint) {
    $.utils.setUint64(24, value, this);
  }
  get modelType(): ModelType {
    return $.utils.getUint16(4, this) as ModelType;
  }
  set modelType(value: ModelType) {
    $.utils.setUint16(4, value, this);
  }
  get format(): ModelFormat {
    return $.utils.getUint16(6, this) as ModelFormat;
  }
  set format(value: ModelFormat) {
    $.utils.setUint16(6, value, this);
  }
  _adoptTags(value: $.Orphan<$.List<string>>): void {
    $.utils.adopt(value, $.utils.getPointer(4, this));
  }
  _disownTags(): $.Orphan<$.List<string>> {
    return $.utils.disown(this.tags);
  }
  get tags(): $.List<string> {
    return $.utils.getList(4, $.TextList, this);
  }
  _hasTags(): boolean {
    return !$.utils.isNull($.utils.getPointer(4, this));
  }
  _initTags(length: number): $.List<string> {
    return $.utils.initList(4, $.TextList, length, this);
  }
  set tags(value: $.List<string>) {
    $.utils.copyFrom(value, $.utils.getPointer(4, this));
  }
  get architecture(): string {
    return $.utils.getText(5, this);
  }
  set architecture(value: string) {
    $.utils.setText(5, value, this);
  }
  get parameterCount(): bigint {
    return $.utils.getUint64(32, this);
  }
  set parameterCount(value: bigint) {
    $.utils.setUint64(32, value, this);
  }
  get quantization(): QuantizationLevel {
    return $.utils.getUint16(40, this) as QuantizationLevel;
  }
  set quantization(value: QuantizationLevel) {
    $.utils.setUint16(40, value, this);
  }
  get license(): string {
    return $.utils.getText(6, this);
  }
  set license(value: string) {
    $.utils.setText(6, value, this);
  }
  get author(): string {
    return $.utils.getText(7, this);
  }
  set author(value: string) {
    $.utils.setText(7, value, this);
  }
  get description(): string {
    return $.utils.getText(8, this);
  }
  set description(value: string) {
    $.utils.setText(8, value, this);
  }
  get estimatedInferenceTimeMs(): number {
    return $.utils.getFloat32(44, this);
  }
  set estimatedInferenceTimeMs(value: number) {
    $.utils.setFloat32(44, value, this);
  }
  get memoryRequiredMb(): number {
    return $.utils.getUint32(48, this);
  }
  set memoryRequiredMb(value: number) {
    $.utils.setUint32(48, value, this);
  }
  get gpuRequired(): boolean {
    return $.utils.getBit(336, this);
  }
  set gpuRequired(value: boolean) {
    $.utils.setBit(336, value, this);
  }
  _adoptLayerChunks(value: $.Orphan<$.List<LayerChunkMapping>>): void {
    $.utils.adopt(value, $.utils.getPointer(9, this));
  }
  _disownLayerChunks(): $.Orphan<$.List<LayerChunkMapping>> {
    return $.utils.disown(this.layerChunks);
  }
  get layerChunks(): $.List<LayerChunkMapping> {
    return $.utils.getList(9, ModelMetadata._LayerChunks, this);
  }
  _hasLayerChunks(): boolean {
    return !$.utils.isNull($.utils.getPointer(9, this));
  }
  _initLayerChunks(length: number): $.List<LayerChunkMapping> {
    return $.utils.initList(9, ModelMetadata._LayerChunks, length, this);
  }
  set layerChunks(value: $.List<LayerChunkMapping>) {
    $.utils.copyFrom(value, $.utils.getPointer(9, this));
  }
  toString(): string { return "ModelMetadata_" + super.toString(); }
}
export class LayerChunkMapping extends $.Struct {
  static readonly _capnp = {
    displayName: "LayerChunkMapping",
    id: "bce74f9c03c65cd3",
    size: new $.ObjectSize(8, 1),
  };
  get layerIndex(): number {
    return $.utils.getUint32(0, this);
  }
  set layerIndex(value: number) {
    $.utils.setUint32(0, value, this);
  }
  _adoptChunkIndices(value: $.Orphan<$.List<number>>): void {
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownChunkIndices(): $.Orphan<$.List<number>> {
    return $.utils.disown(this.chunkIndices);
  }
  get chunkIndices(): $.List<number> {
    return $.utils.getList(0, $.Uint32List, this);
  }
  _hasChunkIndices(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initChunkIndices(length: number): $.List<number> {
    return $.utils.initList(0, $.Uint32List, length, this);
  }
  set chunkIndices(value: $.List<number>) {
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  toString(): string { return "LayerChunkMapping_" + super.toString(); }
}
export const ModelType = {
  LLM: 0,
  VISION: 1,
  AUDIO: 2,
  MULTIMODAL: 3,
  EMBEDDING: 4,
  DIFFUSION: 5
} as const;
export type ModelType = (typeof ModelType)[keyof typeof ModelType];
export const ModelFormat = {
  SAFETENSORS: 0,
  GGUF: 1,
  ONNX: 2,
  PYTORCH: 3,
  TENSORFLOW: 4
} as const;
export type ModelFormat = (typeof ModelFormat)[keyof typeof ModelFormat];
export const QuantizationLevel = {
  FP32: 0,
  FP16: 1,
  INT8: 2,
  INT4: 3
} as const;
export type QuantizationLevel = (typeof QuantizationLevel)[keyof typeof QuantizationLevel];
export class ModelQuery extends $.Struct {
  static readonly _capnp = {
    displayName: "ModelQuery",
    id: "b3cc52f2ed181c6c",
    size: new $.ObjectSize(32, 2),
  };
  get modelType(): ModelType {
    return $.utils.getUint16(0, this) as ModelType;
  }
  set modelType(value: ModelType) {
    $.utils.setUint16(0, value, this);
  }
  _adoptTags(value: $.Orphan<$.List<string>>): void {
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownTags(): $.Orphan<$.List<string>> {
    return $.utils.disown(this.tags);
  }
  get tags(): $.List<string> {
    return $.utils.getList(0, $.TextList, this);
  }
  _hasTags(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initTags(length: number): $.List<string> {
    return $.utils.initList(0, $.TextList, length, this);
  }
  set tags(value: $.List<string>) {
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  get maxSize(): bigint {
    return $.utils.getUint64(8, this);
  }
  set maxSize(value: bigint) {
    $.utils.setUint64(8, value, this);
  }
  get minReputation(): number {
    return $.utils.getFloat32(4, this);
  }
  set minReputation(value: number) {
    $.utils.setFloat32(4, value, this);
  }
  get createdAfter(): bigint {
    return $.utils.getUint64(16, this);
  }
  set createdAfter(value: bigint) {
    $.utils.setUint64(16, value, this);
  }
  get limit(): number {
    return $.utils.getUint16(2, this);
  }
  set limit(value: number) {
    $.utils.setUint16(2, value, this);
  }
  get offset(): number {
    return $.utils.getUint16(24, this);
  }
  set offset(value: number) {
    $.utils.setUint16(24, value, this);
  }
  get searchTerm(): string {
    return $.utils.getText(1, this);
  }
  set searchTerm(value: string) {
    $.utils.setText(1, value, this);
  }
  toString(): string { return "ModelQuery_" + super.toString(); }
}
export class MeshMetrics extends $.Struct {
  static readonly _capnp = {
    displayName: "MeshMetrics",
    id: "eff906508aabafed",
    size: new $.ObjectSize(64, 0),
  };
  get totalPeers(): number {
    return $.utils.getUint32(0, this);
  }
  set totalPeers(value: number) {
    $.utils.setUint32(0, value, this);
  }
  get connectedPeers(): number {
    return $.utils.getUint32(4, this);
  }
  set connectedPeers(value: number) {
    $.utils.setUint32(4, value, this);
  }
  get dhtEntries(): number {
    return $.utils.getUint32(8, this);
  }
  set dhtEntries(value: number) {
    $.utils.setUint32(8, value, this);
  }
  get gossipRatePerSec(): number {
    return $.utils.getFloat32(12, this);
  }
  set gossipRatePerSec(value: number) {
    $.utils.setFloat32(12, value, this);
  }
  get avgReputation(): number {
    return $.utils.getFloat32(16, this);
  }
  set avgReputation(value: number) {
    $.utils.setFloat32(16, value, this);
  }
  get bytesSent(): bigint {
    return $.utils.getUint64(24, this);
  }
  set bytesSent(value: bigint) {
    $.utils.setUint64(24, value, this);
  }
  get bytesReceived(): bigint {
    return $.utils.getUint64(32, this);
  }
  set bytesReceived(value: bigint) {
    $.utils.setUint64(32, value, this);
  }
  get p50LatencyMs(): number {
    return $.utils.getFloat32(20, this);
  }
  set p50LatencyMs(value: number) {
    $.utils.setFloat32(20, value, this);
  }
  get p95LatencyMs(): number {
    return $.utils.getFloat32(40, this);
  }
  set p95LatencyMs(value: number) {
    $.utils.setFloat32(40, value, this);
  }
  get connectionSuccessRate(): number {
    return $.utils.getFloat32(44, this);
  }
  set connectionSuccessRate(value: number) {
    $.utils.setFloat32(44, value, this);
  }
  get chunkFetchSuccessRate(): number {
    return $.utils.getFloat32(48, this);
  }
  set chunkFetchSuccessRate(value: number) {
    $.utils.setFloat32(48, value, this);
  }
  get localChunks(): number {
    return $.utils.getUint32(52, this);
  }
  set localChunks(value: number) {
    $.utils.setUint32(52, value, this);
  }
  get totalChunksAvailable(): number {
    return $.utils.getUint32(56, this);
  }
  set totalChunksAvailable(value: number) {
    $.utils.setUint32(56, value, this);
  }
  toString(): string { return "MeshMetrics_" + super.toString(); }
}
export const ChunkPriority = {
  LOW: 0,
  MEDIUM: 1,
  HIGH: 2,
  CRITICAL: 3
} as const;
export type ChunkPriority = (typeof ChunkPriority)[keyof typeof ChunkPriority];
export const PrefetchPriority = {
  BACKGROUND: 0,
  NORMAL: 1,
  AGGRESSIVE: 2
} as const;
export type PrefetchPriority = (typeof PrefetchPriority)[keyof typeof PrefetchPriority];
export const MeshEvent_Which = {
  PEER_UPDATE: 0,
  CHUNK_DISCOVERED: 1,
  MODEL_REGISTERED: 2,
  REPUTATION_CHANGE: 3
} as const;
export type MeshEvent_Which = (typeof MeshEvent_Which)[keyof typeof MeshEvent_Which];
export class MeshEvent extends $.Struct {
  static readonly PEER_UPDATE = MeshEvent_Which.PEER_UPDATE;
  static readonly CHUNK_DISCOVERED = MeshEvent_Which.CHUNK_DISCOVERED;
  static readonly MODEL_REGISTERED = MeshEvent_Which.MODEL_REGISTERED;
  static readonly REPUTATION_CHANGE = MeshEvent_Which.REPUTATION_CHANGE;
  static readonly _capnp = {
    displayName: "MeshEvent",
    id: "8949bd7ea3dce899",
    size: new $.ObjectSize(8, 1),
  };
  _adoptPeerUpdate(value: $.Orphan<PeerCapability>): void {
    $.utils.setUint16(0, 0, this);
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownPeerUpdate(): $.Orphan<PeerCapability> {
    return $.utils.disown(this.peerUpdate);
  }
  get peerUpdate(): PeerCapability {
    $.utils.testWhich("peerUpdate", $.utils.getUint16(0, this), 0, this);
    return $.utils.getStruct(0, PeerCapability, this);
  }
  _hasPeerUpdate(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initPeerUpdate(): PeerCapability {
    $.utils.setUint16(0, 0, this);
    return $.utils.initStructAt(0, PeerCapability, this);
  }
  get _isPeerUpdate(): boolean {
    return $.utils.getUint16(0, this) === 0;
  }
  set peerUpdate(value: PeerCapability) {
    $.utils.setUint16(0, 0, this);
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  _adoptChunkDiscovered(value: $.Orphan<ChunkDiscovery>): void {
    $.utils.setUint16(0, 1, this);
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownChunkDiscovered(): $.Orphan<ChunkDiscovery> {
    return $.utils.disown(this.chunkDiscovered);
  }
  get chunkDiscovered(): ChunkDiscovery {
    $.utils.testWhich("chunkDiscovered", $.utils.getUint16(0, this), 1, this);
    return $.utils.getStruct(0, ChunkDiscovery, this);
  }
  _hasChunkDiscovered(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initChunkDiscovered(): ChunkDiscovery {
    $.utils.setUint16(0, 1, this);
    return $.utils.initStructAt(0, ChunkDiscovery, this);
  }
  get _isChunkDiscovered(): boolean {
    return $.utils.getUint16(0, this) === 1;
  }
  set chunkDiscovered(value: ChunkDiscovery) {
    $.utils.setUint16(0, 1, this);
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  _adoptModelRegistered(value: $.Orphan<ModelMetadata>): void {
    $.utils.setUint16(0, 2, this);
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownModelRegistered(): $.Orphan<ModelMetadata> {
    return $.utils.disown(this.modelRegistered);
  }
  get modelRegistered(): ModelMetadata {
    $.utils.testWhich("modelRegistered", $.utils.getUint16(0, this), 2, this);
    return $.utils.getStruct(0, ModelMetadata, this);
  }
  _hasModelRegistered(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initModelRegistered(): ModelMetadata {
    $.utils.setUint16(0, 2, this);
    return $.utils.initStructAt(0, ModelMetadata, this);
  }
  get _isModelRegistered(): boolean {
    return $.utils.getUint16(0, this) === 2;
  }
  set modelRegistered(value: ModelMetadata) {
    $.utils.setUint16(0, 2, this);
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  _adoptReputationChange(value: $.Orphan<ReputationUpdate>): void {
    $.utils.setUint16(0, 3, this);
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownReputationChange(): $.Orphan<ReputationUpdate> {
    return $.utils.disown(this.reputationChange);
  }
  get reputationChange(): ReputationUpdate {
    $.utils.testWhich("reputationChange", $.utils.getUint16(0, this), 3, this);
    return $.utils.getStruct(0, ReputationUpdate, this);
  }
  _hasReputationChange(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initReputationChange(): ReputationUpdate {
    $.utils.setUint16(0, 3, this);
    return $.utils.initStructAt(0, ReputationUpdate, this);
  }
  get _isReputationChange(): boolean {
    return $.utils.getUint16(0, this) === 3;
  }
  set reputationChange(value: ReputationUpdate) {
    $.utils.setUint16(0, 3, this);
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  toString(): string { return "MeshEvent_" + super.toString(); }
  which(): MeshEvent_Which {
    return $.utils.getUint16(0, this) as MeshEvent_Which;
  }
}
export class ChunkDiscovery extends $.Struct {
  static readonly _capnp = {
    displayName: "ChunkDiscovery",
    id: "dcbb2bcd85d8a100",
    size: new $.ObjectSize(8, 2),
  };
  get chunkHash(): string {
    return $.utils.getText(0, this);
  }
  set chunkHash(value: string) {
    $.utils.setText(0, value, this);
  }
  get peerId(): string {
    return $.utils.getText(1, this);
  }
  set peerId(value: string) {
    $.utils.setText(1, value, this);
  }
  get priority(): ChunkPriority {
    return $.utils.getUint16(0, this) as ChunkPriority;
  }
  set priority(value: ChunkPriority) {
    $.utils.setUint16(0, value, this);
  }
  toString(): string { return "ChunkDiscovery_" + super.toString(); }
}
export class ReputationUpdate extends $.Struct {
  static readonly _capnp = {
    displayName: "ReputationUpdate",
    id: "fb5a21f73ecdb0c7",
    size: new $.ObjectSize(8, 2),
  };
  get peerId(): string {
    return $.utils.getText(0, this);
  }
  set peerId(value: string) {
    $.utils.setText(0, value, this);
  }
  get newScore(): number {
    return $.utils.getFloat32(0, this);
  }
  set newScore(value: number) {
    $.utils.setFloat32(0, value, this);
  }
  get reason(): string {
    return $.utils.getText(1, this);
  }
  set reason(value: string) {
    $.utils.setText(1, value, this);
  }
  toString(): string { return "ReputationUpdate_" + super.toString(); }
}
export class DHTEntry extends $.Struct {
  static readonly _capnp = {
    displayName: "DHTEntry",
    id: "9741b976e143151f",
    size: new $.ObjectSize(16, 2),
  };
  get key(): string {
    return $.utils.getText(0, this);
  }
  set key(value: string) {
    $.utils.setText(0, value, this);
  }
  _adoptValue(value: $.Orphan<$.List<string>>): void {
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownValue(): $.Orphan<$.List<string>> {
    return $.utils.disown(this.value);
  }
  get value(): $.List<string> {
    return $.utils.getList(1, $.TextList, this);
  }
  _hasValue(): boolean {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initValue(length: number): $.List<string> {
    return $.utils.initList(1, $.TextList, length, this);
  }
  set value(value: $.List<string>) {
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  get timestamp(): bigint {
    return $.utils.getInt64(0, this);
  }
  set timestamp(value: bigint) {
    $.utils.setInt64(0, value, this);
  }
  get ttl(): bigint {
    return $.utils.getInt64(8, this);
  }
  set ttl(value: bigint) {
    $.utils.setInt64(8, value, this);
  }
  toString(): string { return "DHTEntry_" + super.toString(); }
}
P2PMesh_FindPeersWithChunk$Results._Peers = $.CompositeList(PeerCapability);
P2PMesh_GetTopPeers$Results._Peers = $.CompositeList(PeerCapability);
P2PMesh_ListModels$Results._Models = $.CompositeList(ModelMetadata);
ModelMetadata._LayerChunks = $.CompositeList(LayerChunkMapping);
