// Auto-generated by capnpc-ts. DO NOT EDIT.
// source: protocols/schemas/science/v1/science.capnp

export class AllocationQuery {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 0;
  static readonly POINTER_COUNT = 2;
  static readonly TOTAL_BYTES = 16;

  // voxelRange: VoxelRange (pointer at byte offset 0, slot 0)
  // strategy: string (pointer at byte offset 8, slot 1)
}

export class AllocationResponse {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 8;
  static readonly POINTER_COUNT = 1;
  static readonly TOTAL_BYTES = 16;

  // recommendedPeers: List (pointer at byte offset 8, slot 0)
  get confidence(): number { return this._view.getFloat32(this._offset + 0, true); }
  set confidence(v: number) { this._view.setFloat32(this._offset + 0, v, true); }
}

export class StateChunk {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 16;
  static readonly POINTER_COUNT = 4;
  static readonly TOTAL_BYTES = 48;

  // id: Uint8Array (pointer at byte offset 16, slot 0)
  // voxelRange: VoxelRange (pointer at byte offset 24, slot 1)
  // data: Uint8Array (pointer at byte offset 32, slot 2)
  // checksum: Uint8Array (pointer at byte offset 40, slot 3)
  get version(): bigint { return this._view.getBigUint64(this._offset + 0, true); }
  set version(v: bigint) { this._view.setBigUint64(this._offset + 0, v, true); }
  get compressed(): boolean {
    return ((this._view.getUint8(this._offset + 8) >>> 0) & 1) === 1;
  }
  set compressed(v: boolean) {
    const byte = this._view.getUint8(this._offset + 8);
    this._view.setUint8(this._offset + 8, v ? (byte | (1 << 0)) : (byte & ~(1 << 0)));
  }
}

export class VoxelRange {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 0;
  static readonly POINTER_COUNT = 2;
  static readonly TOTAL_BYTES = 16;

  // min: List (pointer at byte offset 0, slot 0)
  // max: List (pointer at byte offset 8, slot 1)
}

export class DataRef {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 8;
  static readonly POINTER_COUNT = 1;
  static readonly TOTAL_BYTES = 16;

  static readonly Which = {
    INLINE: 0,
    HASH: 1,
    MERKLE_PROOF: 2,
  } as const;

  get which(): number { return this._view.getUint16(this._offset + 0, true); }

  // inline: Uint8Array (pointer at byte offset 8, slot 0)
  // hash: Uint8Array (pointer at byte offset 8, slot 0)
  // merkleProof: MerkleProof (pointer at byte offset 8, slot 0)
}

export class MerkleProof {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 0;
  static readonly POINTER_COUNT = 4;
  static readonly TOTAL_BYTES = 32;

  // rootHash: Uint8Array (pointer at byte offset 0, slot 0)
  // leafHash: Uint8Array (pointer at byte offset 8, slot 1)
  // path: List (pointer at byte offset 16, slot 2)
  // indices: List (pointer at byte offset 24, slot 3)
}

export class DeterministicHash {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 16;
  static readonly POINTER_COUNT = 5;
  static readonly TOTAL_BYTES = 56;

  // inputHash: Uint8Array (pointer at byte offset 16, slot 0)
  // methodHash: Uint8Array (pointer at byte offset 24, slot 1)
  // paramsHash: Uint8Array (pointer at byte offset 32, slot 2)
  // resultHash: Uint8Array (pointer at byte offset 40, slot 3)
  get epoch(): bigint { return this._view.getBigUint64(this._offset + 0, true); }
  set epoch(v: bigint) { this._view.setBigUint64(this._offset + 0, v, true); }
  get shard(): number { return this._view.getUint32(this._offset + 8, true); }
  set shard(v: number) { this._view.setUint32(this._offset + 8, v, true); }
  // proofOfWork: Uint8Array (pointer at byte offset 48, slot 4)
}

export class ScienceRequest {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 16;
  static readonly POINTER_COUNT = 7;
  static readonly TOTAL_BYTES = 72;

  get library(): Library { return this._view.getUint16(this._offset + 0, true); }
  set library(v: Library) { this._view.setUint16(this._offset + 0, v, true); }
  // method: string (pointer at byte offset 16, slot 0)
  // params: ScienceParams (pointer at byte offset 24, slot 1)
  // inputData: DataRef (pointer at byte offset 32, slot 2)
  // metadata: Metadata (pointer at byte offset 40, slot 3)
  // computationId: Uint8Array (pointer at byte offset 48, slot 4)
  get cachePolicy(): CachePolicy { return this._view.getUint16(this._offset + 2, true); }
  set cachePolicy(v: CachePolicy) { this._view.setUint16(this._offset + 2, v, true); }
  get priority(): Priority { return this._view.getUint16(this._offset + 4, true); }
  set priority(v: Priority) { this._view.setUint16(this._offset + 4, v, true); }
  // scaleHint: SimulationScale (pointer at byte offset 56, slot 5)
  // expectedResultHash: Uint8Array (pointer at byte offset 64, slot 6)
  get verificationSeed(): bigint { return this._view.getBigUint64(this._offset + 8, true); }
  set verificationSeed(v: bigint) { this._view.setBigUint64(this._offset + 8, v, true); }
}

export const enum Library {
  ATOMIC = 0,
  CONTINUUM = 1,
  KINETIC = 2,
  MATH = 3,
}

export class SimulationScale {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 32;
  static readonly POINTER_COUNT = 0;
  static readonly TOTAL_BYTES = 32;

  get spatial(): number { return this._view.getFloat64(this._offset + 0, true); }
  set spatial(v: number) { this._view.setFloat64(this._offset + 0, v, true); }
  get temporal(): number { return this._view.getFloat64(this._offset + 8, true); }
  set temporal(v: number) { this._view.setFloat64(this._offset + 8, v, true); }
  get energy(): number { return this._view.getFloat64(this._offset + 16, true); }
  set energy(v: number) { this._view.setFloat64(this._offset + 16, v, true); }
  get fidelity(): FidelityLevel { return this._view.getUint16(this._offset + 24, true); }
  set fidelity(v: FidelityLevel) { this._view.setUint16(this._offset + 24, v, true); }
}

export const enum FidelityLevel {
  HEURISTIC = 0,
  ENGINEERING = 1,
  RESEARCH = 2,
  QUANTUM_EXACT = 3,
  REALITY_PROOF = 4,
}

export const enum CachePolicy {
  COMPUTE_ALWAYS = 0,
  CACHE_IF_EXISTS = 1,
  VALIDATE_ONLY = 2,
  STORE_ONLY = 3,
}

export const enum Priority {
  REALTIME = 0,
  INTERACTIVE = 1,
  BATCH = 2,
  BACKGROUND = 3,
}

export class CoupledRequest {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 24;
  static readonly POINTER_COUNT = 2;
  static readonly TOTAL_BYTES = 40;

  // computations: List (pointer at byte offset 24, slot 0)
  // coupling: List (pointer at byte offset 32, slot 1)
  get reconciliation(): ReconciliationMethod { return this._view.getUint16(this._offset + 0, true); }
  set reconciliation(v: ReconciliationMethod) { this._view.setUint16(this._offset + 0, v, true); }
  get tolerance(): number { return this._view.getFloat64(this._offset + 8, true); }
  set tolerance(v: number) { this._view.setFloat64(this._offset + 8, v, true); }
  get shardingStrategy(): ShardingStrategy { return this._view.getUint16(this._offset + 2, true); }
  set shardingStrategy(v: ShardingStrategy) { this._view.setUint16(this._offset + 2, v, true); }
  get synchronizationEpoch(): bigint { return this._view.getBigUint64(this._offset + 16, true); }
  set synchronizationEpoch(v: bigint) { this._view.setBigUint64(this._offset + 16, v, true); }
}

export class CoupledComputation {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 8;
  static readonly POINTER_COUNT = 3;
  static readonly TOTAL_BYTES = 32;

  get id(): number { return this._view.getUint32(this._offset + 0, true); }
  set id(v: number) { this._view.setUint32(this._offset + 0, v, true); }
  // request: ScienceRequest (pointer at byte offset 8, slot 0)
  // scale: SimulationScale (pointer at byte offset 16, slot 1)
  // dependencies: List (pointer at byte offset 24, slot 2)
}

export class ScaleCoupling {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 16;
  static readonly POINTER_COUNT = 1;
  static readonly TOTAL_BYTES = 24;

  get fromId(): number { return this._view.getUint32(this._offset + 0, true); }
  set fromId(v: number) { this._view.setUint32(this._offset + 0, v, true); }
  get toId(): number { return this._view.getUint32(this._offset + 4, true); }
  set toId(v: number) { this._view.setUint32(this._offset + 4, v, true); }
  get couplingType(): CouplingType { return this._view.getUint16(this._offset + 8, true); }
  set couplingType(v: CouplingType) { this._view.setUint16(this._offset + 8, v, true); }
  // mapping: DataRef (pointer at byte offset 16, slot 0)
}

export const enum CouplingType {
  QUANTUM_TO_CONTINUUM = 0,
  CONTINUUM_TO_KINETIC = 1,
  KINETIC_TO_CONTINUUM = 2,
  ALL_TO_ALL = 3,
}

export const enum ReconciliationMethod {
  WEAK_COUPLING = 0,
  STRONG_COUPLING = 1,
  MONOLITHIC = 2,
}

export const enum ShardingStrategy {
  BY_SCALE = 0,
  BY_DOMAIN = 1,
  HYBRID = 2,
  ADAPTIVE = 3,
}

export class CoupledResult {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 24;
  static readonly POINTER_COUNT = 4;
  static readonly TOTAL_BYTES = 56;

  // results: List (pointer at byte offset 24, slot 0)
  // consistencyProof: ConsistencyProof (pointer at byte offset 32, slot 1)
  // globalStateHash: Uint8Array (pointer at byte offset 40, slot 2)
  // merkleRoot: Uint8Array (pointer at byte offset 48, slot 3)
  get nodeSeconds(): number { return this._view.getFloat64(this._offset + 0, true); }
  set nodeSeconds(v: number) { this._view.setFloat64(this._offset + 0, v, true); }
  get dataTransferred(): bigint { return this._view.getBigUint64(this._offset + 8, true); }
  set dataTransferred(v: bigint) { this._view.setBigUint64(this._offset + 8, v, true); }
  get scaleCouplingTime(): number { return this._view.getFloat64(this._offset + 16, true); }
  set scaleCouplingTime(v: number) { this._view.setFloat64(this._offset + 16, v, true); }
}

export class IndividualResult {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 16;
  static readonly POINTER_COUNT = 2;
  static readonly TOTAL_BYTES = 32;

  get computationId(): number { return this._view.getUint32(this._offset + 0, true); }
  set computationId(v: number) { this._view.setUint32(this._offset + 0, v, true); }
  // result: ScienceResult (pointer at byte offset 16, slot 0)
  get nodeId(): bigint { return this._view.getBigUint64(this._offset + 8, true); }
  set nodeId(v: bigint) { this._view.setBigUint64(this._offset + 8, v, true); }
  // verificationHash: Uint8Array (pointer at byte offset 24, slot 1)
}

export class ConsistencyProof {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 24;
  static readonly POINTER_COUNT = 1;
  static readonly TOTAL_BYTES = 32;

  get energyBalance(): number { return this._view.getFloat64(this._offset + 0, true); }
  set energyBalance(v: number) { this._view.setFloat64(this._offset + 0, v, true); }
  get forceMismatch(): number { return this._view.getFloat64(this._offset + 8, true); }
  set forceMismatch(v: number) { this._view.setFloat64(this._offset + 8, v, true); }
  get stressContinuity(): number { return this._view.getFloat64(this._offset + 16, true); }
  set stressContinuity(v: number) { this._view.setFloat64(this._offset + 16, v, true); }
  // proof: MerkleProof (pointer at byte offset 24, slot 0)
}

export class ScienceParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 8;
  static readonly POINTER_COUNT = 1;
  static readonly TOTAL_BYTES = 16;

  static readonly Which = {
    ATOMIC: 0,
    CONTINUUM: 1,
    KINETIC: 2,
    MATH: 3,
    JSON: 4,
    CROSS_SCALE: 5,
    VALIDATION: 6,
    OPTIMIZATION: 7,
    BINARY: 8,
  } as const;

  get which(): number { return this._view.getUint16(this._offset + 0, true); }

  // atomic: AtomicParams (pointer at byte offset 8, slot 0)
  // continuum: ContinuumParams (pointer at byte offset 8, slot 0)
  // kinetic: KineticParams (pointer at byte offset 8, slot 0)
  // math: MathParams (pointer at byte offset 8, slot 0)
  // json: string (pointer at byte offset 8, slot 0)
  // crossScale: CrossScaleParams (pointer at byte offset 8, slot 0)
  // validation: ValidationParams (pointer at byte offset 8, slot 0)
  // optimization: OptimizationParams (pointer at byte offset 8, slot 0)
  // binary: Uint8Array (pointer at byte offset 8, slot 0)
}

export class CrossScaleParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 0;
  static readonly POINTER_COUNT = 0;
  static readonly TOTAL_BYTES = 0;

}

export class ValidationParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 0;
  static readonly POINTER_COUNT = 0;
  static readonly TOTAL_BYTES = 0;

}

export class OptimizationParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 0;
  static readonly POINTER_COUNT = 0;
  static readonly TOTAL_BYTES = 0;

}

export class AtomicParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 8;
  static readonly POINTER_COUNT = 1;
  static readonly TOTAL_BYTES = 16;

  static readonly Which = {
    LOAD_GRO: 0,
    SELECT: 1,
    RMSD: 2,
    CENTER_OF_MASS: 3,
    DISTANCE: 4,
    COMPUTE_ENERGY: 5,
    OPTIMIZE_GEOMETRY: 6,
    COMPUTE_FORCES: 7,
    MOLECULAR_DYNAMICS: 8,
    COMPUTE_DENSITY: 9,
    COMPUTE_ORBITALS: 10,
    DOMAIN_DECOMPOSITION: 11,
  } as const;

  get which(): number { return this._view.getUint16(this._offset + 0, true); }

  // loadGro: string (pointer at byte offset 8, slot 0)
  // select: string (pointer at byte offset 8, slot 0)
  // rmsd: RmsdParams (pointer at byte offset 8, slot 0)
  // distance: DistanceParams (pointer at byte offset 8, slot 0)
  // computeEnergy: QuantumEnergyParams (pointer at byte offset 8, slot 0)
  // optimizeGeometry: OptimizationParams (pointer at byte offset 8, slot 0)
  // molecularDynamics: MDParams (pointer at byte offset 8, slot 0)
  // computeDensity: DensityParams (pointer at byte offset 8, slot 0)
  // computeOrbitals: OrbitalParams (pointer at byte offset 8, slot 0)
  // domainDecomposition: DomainDecomposition (pointer at byte offset 8, slot 0)
}

export class RmsdParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 0;
  static readonly POINTER_COUNT = 2;
  static readonly TOTAL_BYTES = 16;

  // reference: string (pointer at byte offset 0, slot 0)
  // target: string (pointer at byte offset 8, slot 1)
}

export class DistanceParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 0;
  static readonly POINTER_COUNT = 2;
  static readonly TOTAL_BYTES = 16;

  // groupA: string (pointer at byte offset 0, slot 0)
  // groupB: string (pointer at byte offset 8, slot 1)
}

export class QuantumEnergyParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 16;
  static readonly POINTER_COUNT = 3;
  static readonly TOTAL_BYTES = 40;

  // method: string (pointer at byte offset 16, slot 0)
  // basisSet: string (pointer at byte offset 24, slot 1)
  // functional: string (pointer at byte offset 32, slot 2)
  get accuracy(): number { return this._view.getFloat64(this._offset + 0, true); }
  set accuracy(v: number) { this._view.setFloat64(this._offset + 0, v, true); }
  get useSymmetry(): boolean {
    return ((this._view.getUint8(this._offset + 8) >>> 0) & 1) === 1;
  }
  set useSymmetry(v: boolean) {
    const byte = this._view.getUint8(this._offset + 8);
    this._view.setUint8(this._offset + 8, v ? (byte | (1 << 0)) : (byte & ~(1 << 0)));
  }
}

export class MDParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 40;
  static readonly POINTER_COUNT = 1;
  static readonly TOTAL_BYTES = 48;

  get temperature(): number { return this._view.getFloat64(this._offset + 0, true); }
  set temperature(v: number) { this._view.setFloat64(this._offset + 0, v, true); }
  get pressure(): number { return this._view.getFloat64(this._offset + 8, true); }
  set pressure(v: number) { this._view.setFloat64(this._offset + 8, v, true); }
  get steps(): bigint { return this._view.getBigUint64(this._offset + 16, true); }
  set steps(v: bigint) { this._view.setBigUint64(this._offset + 16, v, true); }
  get timestep(): number { return this._view.getFloat64(this._offset + 24, true); }
  set timestep(v: number) { this._view.setFloat64(this._offset + 24, v, true); }
  // thermostat: string (pointer at byte offset 40, slot 0)
  get saveFrequency(): bigint { return this._view.getBigUint64(this._offset + 32, true); }
  set saveFrequency(v: bigint) { this._view.setBigUint64(this._offset + 32, v, true); }
}

export class DensityParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 0;
  static readonly POINTER_COUNT = 0;
  static readonly TOTAL_BYTES = 0;

}

export class OrbitalParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 0;
  static readonly POINTER_COUNT = 0;
  static readonly TOTAL_BYTES = 0;

}

export class DomainDecomposition {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 16;
  static readonly POINTER_COUNT = 1;
  static readonly TOTAL_BYTES = 24;

  // strategy: string (pointer at byte offset 16, slot 0)
  get partitions(): number { return this._view.getUint32(this._offset + 0, true); }
  set partitions(v: number) { this._view.setUint32(this._offset + 0, v, true); }
  get overlap(): number { return this._view.getFloat64(this._offset + 8, true); }
  set overlap(v: number) { this._view.setFloat64(this._offset + 8, v, true); }
}

export class ContinuumParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 8;
  static readonly POINTER_COUNT = 1;
  static readonly TOTAL_BYTES = 16;

  static readonly Which = {
    GENERATE_MESH: 0,
    SOLVE_LINEAR: 1,
    COMPUTE_STRESS: 2,
    COMPUTE_STRAIN: 3,
    COMPUTE_HOMOGENIZED_PROPERTIES: 4,
    APPLY_MICROSTRUCTURE: 5,
    RECEIVE_QUANTUM_FORCES: 6,
    SEND_CONTINUUM_DEFORMATION: 7,
  } as const;

  get which(): number { return this._view.getUint16(this._offset + 0, true); }

  // generateMesh: MeshParams (pointer at byte offset 8, slot 0)
  // solveLinear: SolveParams (pointer at byte offset 8, slot 0)
  // computeHomogenizedProperties: HomogenizationParams (pointer at byte offset 8, slot 0)
  // applyMicrostructure: MicrostructureParams (pointer at byte offset 8, slot 0)
  // receiveQuantumForces: CouplingParams (pointer at byte offset 8, slot 0)
  // sendContinuumDeformation: CouplingParams (pointer at byte offset 8, slot 0)
}

export class MeshParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 8;
  static readonly POINTER_COUNT = 1;
  static readonly TOTAL_BYTES = 16;

  get resolution(): number { return this._view.getUint32(this._offset + 0, true); }
  set resolution(v: number) { this._view.setUint32(this._offset + 0, v, true); }
  // domain: Box3D (pointer at byte offset 8, slot 0)
}

export class SolveParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 8;
  static readonly POINTER_COUNT = 0;
  static readonly TOTAL_BYTES = 8;

  get maxIterations(): number { return this._view.getUint32(this._offset + 0, true); }
  set maxIterations(v: number) { this._view.setUint32(this._offset + 0, v, true); }
  get tolerance(): number { return this._view.getFloat32(this._offset + 4, true); }
  set tolerance(v: number) { this._view.setFloat32(this._offset + 4, v, true); }
}

export class HomogenizationParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 8;
  static readonly POINTER_COUNT = 2;
  static readonly TOTAL_BYTES = 24;

  get rveSize(): number { return this._view.getFloat64(this._offset + 0, true); }
  set rveSize(v: number) { this._view.setFloat64(this._offset + 0, v, true); }
  // boundaryConditions: string (pointer at byte offset 8, slot 0)
  // computeTensor: string (pointer at byte offset 16, slot 1)
}

export class MicrostructureParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 8;
  static readonly POINTER_COUNT = 2;
  static readonly TOTAL_BYTES = 24;

  // type_: string (pointer at byte offset 8, slot 0)
  // orientation: List (pointer at byte offset 16, slot 1)
  get volumeFraction(): number { return this._view.getFloat64(this._offset + 0, true); }
  set volumeFraction(v: number) { this._view.setFloat64(this._offset + 0, v, true); }
}

export class CouplingParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 8;
  static readonly POINTER_COUNT = 3;
  static readonly TOTAL_BYTES = 32;

  // sourceScale: SimulationScale (pointer at byte offset 8, slot 0)
  // targetScale: SimulationScale (pointer at byte offset 16, slot 1)
  // mappingMethod: string (pointer at byte offset 24, slot 2)
  get tolerance(): number { return this._view.getFloat64(this._offset + 0, true); }
  set tolerance(v: number) { this._view.setFloat64(this._offset + 0, v, true); }
}

export class KineticParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 8;
  static readonly POINTER_COUNT = 1;
  static readonly TOTAL_BYTES = 16;

  static readonly Which = {
    CREATE_BODY: 0,
    STEP: 1,
    CAST_RAY: 2,
    CREATE_MANY_BODIES: 3,
    BROAD_PHASE: 4,
    APPLY_CONTINUUM_FORCES: 5,
    SEND_KINETIC_MOTION: 6,
    STEP_PARTICLES: 7,
  } as const;

  get which(): number { return this._view.getUint16(this._offset + 0, true); }

  // createBody: RigidBodyParams (pointer at byte offset 8, slot 0)
  // step: StepParams (pointer at byte offset 8, slot 0)
  // castRay: RayParams (pointer at byte offset 8, slot 0)
  // createManyBodies: ManyBodiesParams (pointer at byte offset 8, slot 0)
  // broadPhase: BroadPhaseParams (pointer at byte offset 8, slot 0)
  // applyContinuumForces: ContinuumForces (pointer at byte offset 8, slot 0)
  // sendKineticMotion: MotionParams (pointer at byte offset 8, slot 0)
  // stepParticles: ParticleRealityParams (pointer at byte offset 8, slot 0)
}

export class RigidBodyParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 8;
  static readonly POINTER_COUNT = 1;
  static readonly TOTAL_BYTES = 16;

  // position: List (pointer at byte offset 8, slot 0)
  get mass(): number { return this._view.getFloat32(this._offset + 0, true); }
  set mass(v: number) { this._view.setFloat32(this._offset + 0, v, true); }
  get isStatic(): boolean {
    return ((this._view.getUint8(this._offset + 4) >>> 0) & 1) === 1;
  }
  set isStatic(v: boolean) {
    const byte = this._view.getUint8(this._offset + 4);
    this._view.setUint8(this._offset + 4, v ? (byte | (1 << 0)) : (byte & ~(1 << 0)));
  }
}

export class StepParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 16;
  static readonly POINTER_COUNT = 0;
  static readonly TOTAL_BYTES = 16;

  get dt(): number { return this._view.getFloat32(this._offset + 0, true); }
  set dt(v: number) { this._view.setFloat32(this._offset + 0, v, true); }
  get sabOffset(): number { return this._view.getUint32(this._offset + 4, true); }
  set sabOffset(v: number) { this._view.setUint32(this._offset + 4, v, true); }
  get particleCount(): number { return this._view.getUint32(this._offset + 8, true); }
  set particleCount(v: number) { this._view.setUint32(this._offset + 8, v, true); }
}

export class ParticleRealityParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 16;
  static readonly POINTER_COUNT = 1;
  static readonly TOTAL_BYTES = 24;

  get sabOffset(): number { return this._view.getUint32(this._offset + 0, true); }
  set sabOffset(v: number) { this._view.setUint32(this._offset + 0, v, true); }
  get particleCount(): number { return this._view.getUint32(this._offset + 4, true); }
  set particleCount(v: number) { this._view.setUint32(this._offset + 4, v, true); }
  get dt(): number { return this._view.getFloat32(this._offset + 8, true); }
  set dt(v: number) { this._view.setFloat32(this._offset + 8, v, true); }
  // gravity: List (pointer at byte offset 16, slot 0)
}

export class RayParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 8;
  static readonly POINTER_COUNT = 2;
  static readonly TOTAL_BYTES = 24;

  // origin: List (pointer at byte offset 8, slot 0)
  // direction: List (pointer at byte offset 16, slot 1)
  get maxToi(): number { return this._view.getFloat32(this._offset + 0, true); }
  set maxToi(v: number) { this._view.setFloat32(this._offset + 0, v, true); }
}

export class ManyBodiesParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 8;
  static readonly POINTER_COUNT = 4;
  static readonly TOTAL_BYTES = 40;

  // positions: DataRef (pointer at byte offset 8, slot 0)
  // velocities: DataRef (pointer at byte offset 16, slot 1)
  // masses: DataRef (pointer at byte offset 24, slot 2)
  // collisionGroups: DataRef (pointer at byte offset 32, slot 3)
  get batchSize(): number { return this._view.getUint32(this._offset + 0, true); }
  set batchSize(v: number) { this._view.setUint32(this._offset + 0, v, true); }
}

export class BroadPhaseParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 8;
  static readonly POINTER_COUNT = 1;
  static readonly TOTAL_BYTES = 16;

  // algorithm: string (pointer at byte offset 8, slot 0)
  get cellSize(): number { return this._view.getFloat32(this._offset + 0, true); }
  set cellSize(v: number) { this._view.setFloat32(this._offset + 0, v, true); }
  get parallel(): boolean {
    return ((this._view.getUint8(this._offset + 4) >>> 0) & 1) === 1;
  }
  set parallel(v: boolean) {
    const byte = this._view.getUint8(this._offset + 4);
    this._view.setUint8(this._offset + 4, v ? (byte | (1 << 0)) : (byte & ~(1 << 0)));
  }
}

export class ContinuumForces {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 8;
  static readonly POINTER_COUNT = 2;
  static readonly TOTAL_BYTES = 24;

  // forceField: DataRef (pointer at byte offset 8, slot 0)
  // interpolation: string (pointer at byte offset 16, slot 1)
  get updateFrequency(): number { return this._view.getUint32(this._offset + 0, true); }
  set updateFrequency(v: number) { this._view.setUint32(this._offset + 0, v, true); }
}

export class MotionParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 0;
  static readonly POINTER_COUNT = 0;
  static readonly TOTAL_BYTES = 0;

}

export class MathParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 8;
  static readonly POINTER_COUNT = 1;
  static readonly TOTAL_BYTES = 16;

  static readonly Which = {
    MATRIX_MULTIPLY: 0,
    DOT_PRODUCT: 1,
    INVERSE: 2,
    EIGENVALUES: 3,
    PARTIAL_TRACE: 4,
    EXPECTATION_VALUE: 5,
    COMMUTATOR: 6,
    TENSOR_PRODUCT: 7,
    DISTRIBUTED_SOLVE: 8,
    REDUCE_OPERATION: 9,
  } as const;

  get which(): number { return this._view.getUint16(this._offset + 0, true); }

  // matrixMultiply: MatMulParams (pointer at byte offset 8, slot 0)
  // partialTrace: PartialTraceParams (pointer at byte offset 8, slot 0)
  // expectationValue: ExpectationParams (pointer at byte offset 8, slot 0)
  // commutator: CommutatorParams (pointer at byte offset 8, slot 0)
  // tensorProduct: TensorProductParams (pointer at byte offset 8, slot 0)
  // distributedSolve: DistributedSolveParams (pointer at byte offset 8, slot 0)
  // reduceOperation: ReduceParams (pointer at byte offset 8, slot 0)
}

export class MatMulParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 0;
  static readonly POINTER_COUNT = 2;
  static readonly TOTAL_BYTES = 16;

  // aShape: List (pointer at byte offset 0, slot 0)
  // bShape: List (pointer at byte offset 8, slot 1)
}

export class PartialTraceParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 0;
  static readonly POINTER_COUNT = 2;
  static readonly TOTAL_BYTES = 16;

  // subsystemsToTrace: List (pointer at byte offset 0, slot 0)
  // systemDimensions: List (pointer at byte offset 8, slot 1)
}

export class ExpectationParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 8;
  static readonly POINTER_COUNT = 2;
  static readonly TOTAL_BYTES = 24;

  // observable: DataRef (pointer at byte offset 8, slot 0)
  // state: DataRef (pointer at byte offset 16, slot 1)
  get computeVariance(): boolean {
    return ((this._view.getUint8(this._offset + 0) >>> 0) & 1) === 1;
  }
  set computeVariance(v: boolean) {
    const byte = this._view.getUint8(this._offset + 0);
    this._view.setUint8(this._offset + 0, v ? (byte | (1 << 0)) : (byte & ~(1 << 0)));
  }
}

export class CommutatorParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 8;
  static readonly POINTER_COUNT = 2;
  static readonly TOTAL_BYTES = 24;

  // a: DataRef (pointer at byte offset 8, slot 0)
  // b: DataRef (pointer at byte offset 16, slot 1)
  get computeAntiCommutator(): boolean {
    return ((this._view.getUint8(this._offset + 0) >>> 0) & 1) === 1;
  }
  set computeAntiCommutator(v: boolean) {
    const byte = this._view.getUint8(this._offset + 0);
    this._view.setUint8(this._offset + 0, v ? (byte | (1 << 0)) : (byte & ~(1 << 0)));
  }
}

export class TensorProductParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 0;
  static readonly POINTER_COUNT = 0;
  static readonly TOTAL_BYTES = 0;

}

export class DistributedSolveParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 16;
  static readonly POINTER_COUNT = 4;
  static readonly TOTAL_BYTES = 48;

  // matrix: DataRef (pointer at byte offset 16, slot 0)
  // rhs: DataRef (pointer at byte offset 24, slot 1)
  // solver: string (pointer at byte offset 32, slot 2)
  // preconditioner: string (pointer at byte offset 40, slot 3)
  get maxIterations(): number { return this._view.getUint32(this._offset + 0, true); }
  set maxIterations(v: number) { this._view.setUint32(this._offset + 0, v, true); }
  get tolerance(): number { return this._view.getFloat64(this._offset + 8, true); }
  set tolerance(v: number) { this._view.setFloat64(this._offset + 8, v, true); }
}

export class ReduceParams {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 8;
  static readonly POINTER_COUNT = 2;
  static readonly TOTAL_BYTES = 24;

  // operation: string (pointer at byte offset 8, slot 0)
  // data: DataRef (pointer at byte offset 16, slot 1)
  get rootNode(): bigint { return this._view.getBigUint64(this._offset + 0, true); }
  set rootNode(v: bigint) { this._view.setBigUint64(this._offset + 0, v, true); }
}

export class ScienceResult {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 8;
  static readonly POINTER_COUNT = 5;
  static readonly TOTAL_BYTES = 48;

  get status(): Status { return this._view.getUint16(this._offset + 0, true); }
  set status(v: Status) { this._view.setUint16(this._offset + 0, v, true); }
  // data: DataRef (pointer at byte offset 8, slot 0)
  // errorMessage: string (pointer at byte offset 16, slot 1)
  // computationProof: ComputationProof (pointer at byte offset 24, slot 2)
  // performance: PerformanceMetrics (pointer at byte offset 32, slot 3)
  // alternatives: List (pointer at byte offset 40, slot 4)
}

export class ComputationProof {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 24;
  static readonly POINTER_COUNT = 6;
  static readonly TOTAL_BYTES = 72;

  // inputHash: Uint8Array (pointer at byte offset 24, slot 0)
  // methodHash: Uint8Array (pointer at byte offset 32, slot 1)
  // paramsHash: Uint8Array (pointer at byte offset 40, slot 2)
  // resultHash: Uint8Array (pointer at byte offset 48, slot 3)
  get nodeId(): bigint { return this._view.getBigUint64(this._offset + 0, true); }
  set nodeId(v: bigint) { this._view.setBigUint64(this._offset + 0, v, true); }
  get shardId(): number { return this._view.getUint32(this._offset + 8, true); }
  set shardId(v: number) { this._view.setUint32(this._offset + 8, v, true); }
  get epoch(): bigint { return this._view.getBigUint64(this._offset + 16, true); }
  set epoch(v: bigint) { this._view.setBigUint64(this._offset + 16, v, true); }
  // verificationData: DataRef (pointer at byte offset 56, slot 4)
  // merkleProof: MerkleProof (pointer at byte offset 64, slot 5)
}

export class PerformanceMetrics {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 32;
  static readonly POINTER_COUNT = 1;
  static readonly TOTAL_BYTES = 40;

  get computeTime(): number { return this._view.getFloat64(this._offset + 0, true); }
  set computeTime(v: number) { this._view.setFloat64(this._offset + 0, v, true); }
  get memoryUsed(): bigint { return this._view.getBigUint64(this._offset + 8, true); }
  set memoryUsed(v: bigint) { this._view.setBigUint64(this._offset + 8, v, true); }
  get cacheHit(): boolean {
    return ((this._view.getUint8(this._offset + 16) >>> 0) & 1) === 1;
  }
  set cacheHit(v: boolean) {
    const byte = this._view.getUint8(this._offset + 16);
    this._view.setUint8(this._offset + 16, v ? (byte | (1 << 0)) : (byte & ~(1 << 0)));
  }
  // scale: SimulationScale (pointer at byte offset 32, slot 0)
  get accuracy(): number { return this._view.getFloat64(this._offset + 24, true); }
  set accuracy(v: number) { this._view.setFloat64(this._offset + 24, v, true); }
}

export class ValidationProof {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 32;
  static readonly POINTER_COUNT = 3;
  static readonly TOTAL_BYTES = 56;

  // originalHash: Uint8Array (pointer at byte offset 32, slot 0)
  // validationMethod: string (pointer at byte offset 40, slot 1)
  get isValid(): boolean {
    return ((this._view.getUint8(this._offset + 0) >>> 0) & 1) === 1;
  }
  set isValid(v: boolean) {
    const byte = this._view.getUint8(this._offset + 0);
    this._view.setUint8(this._offset + 0, v ? (byte | (1 << 0)) : (byte & ~(1 << 0)));
  }
  // validatorResult: DataRef (pointer at byte offset 48, slot 2)
  get validatorNode(): bigint { return this._view.getBigUint64(this._offset + 8, true); }
  set validatorNode(v: bigint) { this._view.setBigUint64(this._offset + 8, v, true); }
  get stake(): bigint { return this._view.getBigUint64(this._offset + 16, true); }
  set stake(v: bigint) { this._view.setBigUint64(this._offset + 16, v, true); }
  get reward(): bigint { return this._view.getBigUint64(this._offset + 24, true); }
  set reward(v: bigint) { this._view.setBigUint64(this._offset + 24, v, true); }
}

export class Box3D {
  private _view: DataView;
  private _offset: number;

  constructor(buffer: ArrayBuffer, offset: number = 0) {
    this._view = new DataView(buffer);
    this._offset = offset;
  }

  static readonly DATA_BYTES = 0;
  static readonly POINTER_COUNT = 2;
  static readonly TOTAL_BYTES = 16;

  // min: List (pointer at byte offset 0, slot 0)
  // max: List (pointer at byte offset 8, slot 1)
}

export const enum Status {
  SUCCESS = 0,
  ERROR = 1,
  INVALID_PARAMS = 2,
  CACHE_HIT = 3,
  VALIDATION_REQUIRED = 4,
  SCALE_MISMATCH = 5,
}

